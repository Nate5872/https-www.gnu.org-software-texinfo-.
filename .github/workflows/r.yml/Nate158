# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
#
# See https://github.com/r-lib/actions/tree/master/examples#readme for
# additional example workflows available for the R community.

name: R

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: macos-latest
    strategy:
      matrix:
        r-version: ['3.6.3', '4.1.1']

    steps:
      - uses: actions/checkout@v2
      - name: Set up R ${{ matrix.r-version }}
        uses: r-lib/actions/setup-r@f57f1301a053485946083d7a45022b278929a78a
        with:
          r-version: ${{ matrix.r-version }}
      - name: Install dependencies
        run: |
          install.packages(c("remotes", "rcmdcheck"))
          remotes::install_deps(dependencies = TRUE)
        shell: Rscript {0}
      - name: Check
        run: rcmdcheck::rcmdcheck(args = "--no-manual", error_on = "error")
        shell: Rscript {0}
     -  
 ​const​ ​{​ expect ​}​ ​=​ ​require​(​'chai'​)​; 
 ​require​(​'chai'​)​.​should​(​)​; 
 ​const​ ​{​ ​BN​,​ constants​,​ expectEvent​,​ expectRevert​,​ time ​}​ ​=​ ​require​(​'@openzeppelin/test-helpers'​)​; 
 ​// const { accounts, contract, web3 } = require('@openzeppelin/test-environment'); 
 ​// const CoFiXRouter = contract.fromArtifact("CoFiXRouter"); 
 ​// const ERC20 = contract.fromArtifact("ERC20"); 
 ​// const CoFiXFactory = contract.fromArtifact("CoFiXFactory"); 
 ​// const CoFiXPair = contract.fromArtifact("CoFiXPair"); 
 ​// const WETH9 = contract.fromArtifact("WETH9"); 
 ​// const NEST3PriceOracleMock = contract.fromArtifact("NEST3PriceOracleMock"); 
 ​// const CoFiXController = contract.fromArtifact("CoFiXController"); 
  
 ​const​ ​CoFiXRouter​ ​=​ ​artifacts​.​require​(​"CoFiXRouter"​)​; 
 ​// const ERC20 = artifacts.require("TestERC20"); 
 ​const​ ​CoFiXFactory​ ​=​ ​artifacts​.​require​(​"CoFiXFactory"​)​; 
 ​const​ ​CoFiXPair​ ​=​ ​artifacts​.​require​(​"CoFiXPair"​)​; 
 ​const​ ​WETH9​ ​=​ ​artifacts​.​require​(​"WETH9"​)​; 
 ​const​ ​NEST3PriceOracleMock​ ​=​ ​artifacts​.​require​(​"mock/NEST3PriceOracleMock"​)​; 
 ​const​ ​CoFiXController​ ​=​ ​artifacts​.​require​(​"CoFiXController"​)​; 
 ​const​ ​CoFiXKTable​ ​=​ ​artifacts​.​require​(​"CoFiXKTable"​)​; 
 ​const​ ​TestUSDT​ ​=​ ​artifacts​.​require​(​"test/USDT"​)​; 
 ​const​ ​TestHBTC​ ​=​ ​artifacts​.​require​(​"test/HBTC"​)​; 
 ​const​ ​TestNEST​ ​=​ ​artifacts​.​require​(​"test/NEST"​)​; 
  
 ​const​ ​NEST3VoteFactoryMock​ ​=​ ​artifacts​.​require​(​"NEST3VoteFactoryMock"​)​; 
  
 ​const​ ​CoFiToken​ ​=​ ​artifacts​.​require​(​"CoFiToken"​)​; 
 ​const​ ​CoFiXVaultForLP​ ​=​ ​artifacts​.​require​(​"CoFiXVaultForLP"​)​; 
 ​const​ ​CoFiXStakingRewards​ ​=​ ​artifacts​.​require​(​"CoFiXStakingRewards.sol"​)​; 
  
 ​const​ ​{​ printKInfoEvent ​}​ ​=​ ​require​(​'../lib/print'​)​; 
 ​const​ ​Decimal​ ​=​ ​require​(​'decimal.js'​)​; 
 ​const​ ​{​ calcK​,​ convert_from_fixed_point​,​ convert_into_fixed_point​,​ calcRelativeDiff ​}​ ​=​ ​require​(​'../lib/calc'​)​; 
  
 ​const​ ​errorDelta​ ​=​ ​10​ ​**​ ​-​10​; 
  
  
 ​contract​(​'CoFiX'​,​ ​(​accounts​)​ ​=>​ ​{ 
 ​// describe('CoFiX', function () { 
 ​    ​// const [owner] = accounts; 
 ​    ​const​ ​owner​ ​=​ ​accounts​[​0​]​; 
 ​    ​let​ ​deployer​ ​=​ ​owner​; 
 ​    ​let​ ​LP​ ​=​ ​owner​; 
 ​    ​let​ ​trader​ ​=​ ​owner​; 
  
 ​    ​// let totalSupply_ = "10000000000000000"; 
 ​    ​const​ ​USDTTotalSupply_​ ​=​ ​new​ ​BN​(​"10000000000000000"​)​; 
 ​    ​const​ ​HBTCTotalSupply_​ ​=​ ​new​ ​BN​(​"100000000000000000000000000"​)​; 
  
 ​    ​const​ ​DESTRUCTION_AMOUNT​ ​=​ ​web3​.​utils​.​toWei​(​'0'​,​ ​'ether'​)​; 
  
 ​    ​// enum POOL_STATE {INVALID, ENABLED, DISABLED} 
 ​    ​const​ ​POOL_STATE_INVALID​ ​=​ ​"0"​; 
 ​    ​const​ ​POOL_STATE_ENABLED​ ​=​ ​"1"​; 
 ​    ​const​ ​POOL_STATE_DISABLED​ ​=​ ​"2"​; 
  
 ​    ​before​(​async​ ​(​)​ ​=>​ ​{ 
 ​        ​// change to openzeppelin/test-environment if it has better support for test coverage and gas cost measure 
 ​        ​// USDT = await ERC20.new("10000000000000000", "USDT Test Token", "USDT", 6, { from: deployer }); 
 ​        ​// WETH = await WETH9.new(); 
 ​        ​// PriceOracle = await NEST3PriceOracleMock.new(); 
 ​        ​// CoFiXCtrl = await CoFiXController.new(PriceOracle.address); 
 ​        ​// CFactory = await CoFiXFactory.new(CoFiXCtrl.address, WETH.address) 
 ​        ​// CRouter = await CoFiXRouter.new(CFactory.address, WETH.address); 
 ​        ​// USDT = await ERC20.new("10000000000000000", "USDT Test Token", "USDT", 6, { from: deployer }); 
 ​        ​// HBTC = await ERC20.new("100000000000000000000000000", "Huobi BTC", "HBTC", 18, { from: deployer }); 
 ​        ​USDT​ ​=​ ​await​ ​TestUSDT​.​new​(​)​; 
 ​        ​HBTC​ ​=​ ​await​ ​TestHBTC​.​new​(​)​; 
 ​        ​// WETH = await WETH9.deployed(); 
 ​        ​// NEST = await TestNEST.deployed() 
 ​        ​// PriceOracle = await NEST3PriceOracleMock.deployed(); 
 ​        ​// CoFiXCtrl = await CoFiXController.deployed(); 
 ​        ​// // CoFiXCtrl.initialize(PriceOracle.address, { from: deployer }); 
 ​        ​// CFactory = await CoFiXFactory.deployed(); 
 ​        ​// CRouter = await CoFiXRouter.deployed(); 
  
 ​        ​NEST​ ​=​ ​await​ ​TestNEST​.​new​(​{​ ​from​: ​deployer​ ​}​)​; 
 ​        ​WETH​ ​=​ ​await​ ​WETH9​.​new​(​)​; 
 ​        ​CoFi​ ​=​ ​await​ ​CoFiToken​.​new​(​{​ ​from​: ​deployer​ ​}​)​; 
 ​        ​CFactory​ ​=​ ​await​ ​CoFiXFactory​.​new​(​WETH​.​address​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​        ​VaultForLP​ ​=​ ​await​ ​CoFiXVaultForLP​.​new​(​CoFi​.​address​,​ ​CFactory​.​address​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​        ​await​ ​CFactory​.​setVaultForLP​(​VaultForLP​.​address​)​; 
 ​        ​PriceOracle​ ​=​ ​await​ ​NEST3PriceOracleMock​.​new​(​NEST​.​address​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​        ​NEST3VoteFactory​ ​=​ ​await​ ​NEST3VoteFactoryMock​.​new​(​PriceOracle​.​address​)​; 
 ​        ​KTable​ ​=​ ​await​ ​CoFiXKTable​.​new​(​{​ ​from​: ​deployer​ ​}​)​; 
 ​        ​CoFiXCtrl​ ​=​ ​await​ ​CoFiXController​.​new​(​NEST3VoteFactory​.​address​,​ ​NEST​.​address​,​ ​CFactory​.​address​,​ ​KTable​.​address​)​; 
 ​        ​await​ ​CFactory​.​setController​(​CoFiXCtrl​.​address​)​; 
 ​        ​// await CoFiXCtrl.initialize(ConstOracle.address, { from: deployer }); 
 ​        ​CRouter​ ​=​ ​await​ ​CoFiXRouter​.​new​(​CFactory​.​address​,​ ​WETH​.​address​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​    ​}​)​; 
  
 ​    ​describe​(​'template'​,​ ​function​ ​(​)​ ​{ 
 ​        ​it​(​"test"​,​ ​async​ ​(​)​ ​=>​ ​{ 
 ​        ​}​)​; 
 ​    ​}​)​; 
  
 ​    ​describe​(​'ERC20 Token'​,​ ​function​ ​(​)​ ​{ 
 ​        ​it​(​"should USDT totalSupply equals"​,​ ​async​ ​(​)​ ​=>​ ​{ 
 ​            ​let​ ​totalSupply​ ​=​ ​await​ ​USDT​.​totalSupply​(​)​; 
 ​            ​expect​(​totalSupply​)​.​to​.​bignumber​.​equal​(​USDTTotalSupply_​)​; 
 ​        ​}​) 
 ​    ​}​)​; 
  
 ​    ​describe​(​'CoFiXController'​,​ ​function​ ​(​)​ ​{​   
  
 ​        ​it​(​"should activate nest oracle correctly"​,​ ​async​ ​(​)​ ​=>​ ​{ 
 ​            ​await​ ​NEST​.​approve​(​CoFiXCtrl​.​address​,​ ​DESTRUCTION_AMOUNT​)​; 
 ​            ​await​ ​CoFiXCtrl​.​activate​(​)​; 
 ​            ​await​ ​time​.​increase​(​time​.​duration​.​minutes​(​1​)​)​;​ ​// increase time to make activation be effective 
 ​        ​}​)​; 
  
 ​        ​it​(​"should activate again correctly by governance"​,​ ​async​ ​(​)​ ​=>​ ​{ 
 ​            ​await​ ​NEST​.​approve​(​CoFiXCtrl​.​address​,​ ​DESTRUCTION_AMOUNT​)​; 
 ​            ​await​ ​CoFiXCtrl​.​activate​(​)​; 
 ​            ​await​ ​time​.​increase​(​time​.​duration​.​minutes​(​1​)​)​;​ ​// increase time to make activation be effective 
 ​        ​}​)​; 
  
 ​        ​it​(​"K calculation"​,​ ​async​ ​(​)​ ​=>​ ​{ 
 ​            ​console​.​log​(​"======================CoFiXController TEST START======================"​)​; 
 ​            ​_msgValue​ ​=​ ​web3​.​utils​.​toWei​(​'0.01'​,​ ​'ether'​)​; 
  
 ​            ​// add enough prices in NEST3PriceOracleMock 
 ​            ​let​ ​ethAmount​ ​=​ ​new​ ​BN​(​"10000000000000000000"​)​; 
 ​            ​let​ ​usdtAmount​ ​=​ ​new​ ​BN​(​"3255000000"​)​; 
  
 ​            ​for​ ​(​let​ ​i​ ​=​ ​0​;​ ​i​ ​<​ ​50​;​ ​i​++​)​ ​{ 
 ​                ​await​ ​PriceOracle​.​addPriceToList​(​USDT​.​address​,​ ​ethAmount​,​ ​usdtAmount​,​ ​"0"​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​                ​usdtAmount​ ​=​ ​usdtAmount​.​mul​(​new​ ​BN​(​"100"​)​)​.​div​(​new​ ​BN​(​"100"​)​)​;​ ​// very stable price 
 ​            ​} 
 ​            ​let​ ​priceLen​ ​=​ ​await​ ​PriceOracle​.​getPriceLength​(​USDT​.​address​)​; 
 ​            ​console​.​log​(​"USDT>priceLen:"​,​ ​priceLen​.​toString​(​)​,​ ​", tokenAmount:"​,​ ​usdtAmount​.​toString​(​)​)​; 
 ​            ​expect​(​priceLen​)​.​to​.​bignumber​.​equal​(​new​ ​BN​(​"50"​)​)​; 
  
 ​            ​// add caller 
 ​            ​await​ ​CoFiXCtrl​.​addCaller​(​deployer​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
  
 ​            ​// let gas = await CoFiXCtrl.methods['queryOracle(address,address)'].estimateGas(USDT.address, deployer, { from: deployer }) 
 ​            ​// console.log("estimateGas:", gas.toString()) 
 ​            ​let​ ​result​ ​=​ ​await​ ​CoFiXCtrl​.​queryOracle​(​USDT​.​address​,​ ​"0"​,​ ​deployer​,​ ​{​ ​from​: ​deployer​,​ ​value​: ​_msgValue​ ​}​)​; 
 ​            ​console​.​log​(​"USDT>receipt.gasUsed:"​,​ ​result​.​receipt​.​gasUsed​)​;​ ​// 494562 
 ​            ​// let evtArgs0 = result.receipt.logs[0].args; 
 ​            ​// printKInfoEvent(evtArgs0); 
 ​            ​// console.log("USDT>evtArgs0> K:", evtArgs0.K.toString(), ", sigma:", evtArgs0.sigma.toString(), ", T:", evtArgs0.T.toString(), ", ethAmount:", evtArgs0.ethAmount.toString(), ", erc20Amount:", evtArgs0.erc20Amount.toString()); 
 ​            ​// K = -0.016826326, when sigma equals to zero 
  
 ​            ​// add more prices 
 ​            ​for​ ​(​let​ ​i​ ​=​ ​0​;​ ​i​ ​<​ ​50​;​ ​i​++​)​ ​{ 
 ​                ​await​ ​PriceOracle​.​addPriceToList​(​USDT​.​address​,​ ​ethAmount​,​ ​usdtAmount​,​ ​"0"​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​                ​usdtAmount​ ​=​ ​usdtAmount​.​mul​(​new​ ​BN​(​"101"​)​)​.​div​(​new​ ​BN​(​"100"​)​)​;​ ​// eth price rising 
 ​            ​} 
 ​            ​priceLen​ ​=​ ​await​ ​PriceOracle​.​getPriceLength​(​USDT​.​address​)​; 
 ​            ​console​.​log​(​"USDT>priceLen:"​,​ ​priceLen​.​toString​(​)​,​ ​", tokenAmount:"​,​ ​usdtAmount​.​toString​(​)​)​; 
 ​            ​expect​(​priceLen​)​.​to​.​bignumber​.​equal​(​new​ ​BN​(​"100"​)​)​; 
 ​            ​result​ ​=​ ​await​ ​CoFiXCtrl​.​queryOracle​(​USDT​.​address​,​ ​"0"​,​ ​deployer​,​ ​{​ ​from​: ​deployer​,​ ​value​: ​_msgValue​ ​}​)​; 
 ​            ​console​.​log​(​"USDT>receipt.gasUsed:"​,​ ​result​.​receipt​.​gasUsed​)​;​ ​// 544914 
 ​            ​if​ ​(​result​.​receipt​.​logs​[​0​]​)​ ​{ 
 ​                ​evtArgs0​ ​=​ ​result​.​receipt​.​logs​[​0​]​.​args​; 
 ​                ​printKInfoEvent​(​evtArgs0​)​; 
 ​            ​} 
  
 ​            ​// console.log("USDT>evtArgs0> K:", evtArgs0.K.toString(), ", sigma:", evtArgs0.sigma.toString(), ", T:", evtArgs0.T.toString(), ", ethAmount:", evtArgs0.ethAmount.toString(), ", erc20Amount:", evtArgs0.erc20Amount.toString()) 
 ​            ​// python result, K=-0.009217843036355746, sigma=0.0004813196086030222 
 ​            ​// contract result, K=-170039189510192419/(2**64)=-0.00921784293373125, sigma=8878779697438274/(2**64)=0.0004813196118491383 
  
 ​            ​// debug 
 ​            ​let​ ​p​ ​=​ ​await​ ​PriceOracle​.​priceInfoList_​(​USDT​.​address​,​ ​99​)​; 
 ​            ​console​.​log​(​"debug>USDT>p:"​,​ ​p​.​ethAmount​.​toString​(​)​,​ ​p​.​erc20Amount​.​toString​(​)​,​ ​p​.​blockNum​.​toString​(​)​)​; 
 ​            ​let​ ​c​ ​=​ ​await​ ​PriceOracle​.​checkPriceList​(​USDT​.​address​,​ ​50​)​; 
 ​            ​console​.​log​(​"debug>USDT>c:"​,​ ​c​[​0​]​.​toString​(​)​,​ ​c​[​1​]​.​toString​(​)​,​ ​c​[​2​]​.​toString​(​)​,​ ​c​[​3​]​.​toString​(​)​,​ ​c​[​4​]​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"======================CoFiXController STATS END======================"​)​; 
  
 ​            ​// add price for HBTC 
 ​            ​let​ ​hbtcAmount​ ​=​ ​new​ ​BN​(​"339880000000000000"​)​; 
 ​            ​for​ ​(​let​ ​i​ ​=​ ​0​;​ ​i​ ​<​ ​50​;​ ​i​++​)​ ​{ 
 ​                ​await​ ​PriceOracle​.​addPriceToList​(​HBTC​.​address​,​ ​ethAmount​,​ ​hbtcAmount​,​ ​"0"​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​                ​hbtcAmount​ ​=​ ​hbtcAmount​.​mul​(​new​ ​BN​(​"100"​)​)​.​div​(​new​ ​BN​(​"100"​)​)​;​ ​// very stable price 
 ​            ​} 
 ​            ​let​ ​priceLenBTC​ ​=​ ​await​ ​PriceOracle​.​getPriceLength​(​HBTC​.​address​)​; 
 ​            ​console​.​log​(​"HBTC>priceLen:"​,​ ​priceLenBTC​.​toString​(​)​,​ ​", tokenAmount:"​,​ ​hbtcAmount​.​toString​(​)​)​; 
 ​            ​expect​(​priceLenBTC​)​.​to​.​bignumber​.​equal​(​new​ ​BN​(​"50"​)​)​; 
 ​        ​}​) 
 ​    ​}​)​; 
  
 ​    ​describe​(​'Main flow'​,​ ​function​ ​(​)​ ​{ 
 ​        ​it​(​"should run correctly"​,​ ​async​ ​(​)​ ​=>​ ​{ 
 ​            ​let​ ​priceLenUSDT​ ​=​ ​await​ ​PriceOracle​.​getPriceLength​(​USDT​.​address​)​; 
 ​            ​console​.​log​(​"USDT priceLen:"​,​ ​priceLenUSDT​.​toString​(​)​)​; 
  
 ​            ​let​ ​priceLenHBTC​ ​=​ ​await​ ​PriceOracle​.​getPriceLength​(​HBTC​.​address​)​; 
 ​            ​console​.​log​(​"HBTC priceLen:"​,​ ​priceLenHBTC​.​toString​(​)​)​; 
  
 ​            ​// approve USDT to router 
 ​            ​await​ ​USDT​.​approve​(​CRouter​.​address​,​ ​USDTTotalSupply_​,​ ​{​ ​from​: ​LP​ ​}​)​; 
  
 ​            ​// check if approve successfully 
 ​            ​let​ ​allowance​ ​=​ ​await​ ​USDT​.​allowance​(​LP​,​ ​CRouter​.​address​)​; 
 ​            ​console​.​log​(​"allowanceUSDT: "​,​ ​allowance​.​toString​(​)​)​; 
 ​            ​expect​(​allowance​)​.​to​.​bignumber​.​equal​(​USDTTotalSupply_​)​; 
  
  
 ​            ​let​ ​ethAmount​ ​=​ ​new​ ​BN​(​"10000000000000000000"​)​; 
 ​            ​let​ ​usdtAmount​ ​=​ ​new​ ​BN​(​"3255000000"​)​; 
 ​            ​let​ ​hbtcAmount​ ​=​ ​new​ ​BN​(​"339880000000000000"​)​; 
 ​            ​for​ ​(​let​ ​i​ ​=​ ​0​;​ ​i​ ​<​ ​50​;​ ​i​++​)​ ​{ 
 ​                ​await​ ​PriceOracle​.​addPriceToList​(​USDT​.​address​,​ ​ethAmount​,​ ​usdtAmount​,​ ​"0"​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​            ​} 
 ​            ​for​ ​(​let​ ​i​ ​=​ ​0​;​ ​i​ ​<​ ​50​;​ ​i​++​)​ ​{ 
 ​                ​await​ ​PriceOracle​.​addPriceToList​(​HBTC​.​address​,​ ​ethAmount​,​ ​hbtcAmount​,​ ​"0"​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​            ​} 
  
 ​            ​// addLiquidity (create pair included) 
 ​            ​//  - address token, 
 ​            ​//  - uint amountETH, 
 ​            ​//  - uint amountToken, 
 ​            ​//  - uint liquidityMin, 
 ​            ​//  - address to, 
 ​            ​//  - uint deadline 
 ​            ​let​ ​_amountETH​ ​=​ ​web3​.​utils​.​toWei​(​'1'​,​ ​'ether'​)​; 
 ​            ​let​ ​_msgValue​ ​=​ ​web3​.​utils​.​toWei​(​'1.1'​,​ ​'ether'​)​; 
 ​            ​let​ ​_amountToken​ ​=​ ​"1000000000"​; 
 ​            ​let​ ​result​ ​=​ ​await​ ​CRouter​.​addLiquidity​(​USDT​.​address​,​ ​_amountETH​,​ ​_amountToken​,​ ​0​,​ ​LP​,​ ​"99999999999"​,​ ​{​ ​from​: ​LP​,​ ​value​: ​_msgValue​ ​}​)​;​ ​// create pair automatically if not exists 
 ​            ​let​ ​usdtPairAddr​ ​=​ ​await​ ​CFactory​.​getPair​(​USDT​.​address​)​; 
 ​            ​let​ ​USDTPair​ ​=​ ​await​ ​CoFiXPair​.​at​(​usdtPairAddr​)​; 
 ​            ​console​.​log​(​"------------addLiquidity for USDT/ETH------------"​)​; 
 ​            ​const​ ​pairName​ ​=​ ​await​ ​USDTPair​.​name​(​)​; 
 ​            ​const​ ​pairSymbol​ ​=​ ​await​ ​USDTPair​.​symbol​(​)​; 
 ​            ​console​.​log​(​`pair name: ​${​pairName​}​, pair symbol: ​${​pairSymbol​}​`​)​; 
 ​            ​// pair name: CoFiX Pool Token 1, pair symbol: CPT-1 
  
 ​            ​expect​(​pairName​)​.​to​.​equal​(​"XToken 1"​)​; 
 ​            ​expect​(​pairSymbol​)​.​to​.​equal​(​"XT-1"​)​; 
  
 ​            ​let​ ​liquidityUSDTPair​ ​=​ ​await​ ​USDTPair​.​balanceOf​(​LP​)​; 
 ​            ​let​ ​usdtInUSDTPool​ ​=​ ​await​ ​USDT​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​let​ ​wethInUSDTPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​let​ ​ethUserBalance​ ​=​ ​await​ ​web3​.​utils​.​fromWei​(​await​ ​web3​.​eth​.​getBalance​(​LP​)​,​ ​'ether'​) 
 ​            ​let​ ​usdtUserBalance​ ​=​ ​await​ ​USDT​.​balanceOf​(​LP​)​; 
 ​            ​let​ ​hbtcUserBalance​ ​=​ ​await​ ​HBTC​.​balanceOf​(​LP​)​; 
 ​            ​console​.​log​(​"receipt.gasUsed:"​,​ ​result​.​receipt​.​gasUsed​)​; 
 ​            ​console​.​log​(​"pool balance USDT:"​,​ ​usdtInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"pool balance WETH:"​,​ ​wethInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"got liquidity ETH/USDT:"​,​ ​liquidityUSDTPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance ETH:"​,​ ​ethUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance USDT:"​,​ ​usdtUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance HBTC:"​,​ ​hbtcUserBalance​.​toString​(​)​)​; 
 ​             
 ​             
 ​            ​{ 
 ​                ​// for benchmark gas cost when not creating new pair 
 ​                ​for​ ​(​let​ ​i​ ​=​ ​0​;​ ​i​ ​<​ ​10​;​ ​i​++​)​ ​{ 
 ​                    ​await​ ​CRouter​.​addLiquidity​(​USDT​.​address​,​ ​_amountETH​,​ ​_amountToken​,​ ​0​,​ ​LP​,​ ​"99999999999"​,​ ​{​ ​from​: ​LP​,​ ​value​: ​_msgValue​ ​}​)​; 
 ​                ​} 
 ​            ​} 
  
 ​            ​// refresh price list 
 ​            ​for​ ​(​let​ ​i​ ​=​ ​0​;​ ​i​ ​<​ ​1​;​ ​i​++​)​ ​{ 
 ​                ​await​ ​PriceOracle​.​addPriceToList​(​USDT​.​address​,​ ​ethAmount​,​ ​usdtAmount​,​ ​"0"​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​            ​} 
 ​            ​for​ ​(​let​ ​i​ ​=​ ​0​;​ ​i​ ​<​ ​1​;​ ​i​++​)​ ​{ 
 ​                ​await​ ​PriceOracle​.​addPriceToList​(​HBTC​.​address​,​ ​ethAmount​,​ ​hbtcAmount​,​ ​"0"​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​            ​} 
  
 ​            ​// add liquidity for HBTC 
 ​            ​// approve HBTC to router 
 ​            ​await​ ​HBTC​.​approve​(​CRouter​.​address​,​ ​HBTCTotalSupply_​,​ ​{​ ​from​: ​LP​ ​}​)​; 
 ​            ​// check if approve successfully 
 ​            ​let​ ​allowanceHBTC​ ​=​ ​await​ ​HBTC​.​allowance​(​LP​,​ ​CRouter​.​address​)​; 
 ​            ​console​.​log​(​"allowanceHBTC: "​,​ ​allowanceHBTC​.​toString​(​)​)​; 
 ​            ​expect​(​allowanceHBTC​)​.​to​.​bignumber​.​equal​(​HBTCTotalSupply_​)​; 
 ​            ​_amountETH​ ​=​ ​web3​.​utils​.​toWei​(​'1'​,​ ​'ether'​)​; 
 ​            ​let​ ​_amountHBTC​ ​=​ ​"2000000000000000000" 
 ​            ​result​ ​=​ ​await​ ​CRouter​.​addLiquidity​(​HBTC​.​address​,​ ​_amountETH​,​ ​_amountHBTC​,​ ​0​,​ ​LP​,​ ​"99999999999"​,​ ​{​ ​from​: ​LP​,​ ​value​: ​_msgValue​ ​}​)​;​ ​// create pair automatically if not exists 
 ​            ​let​ ​hbtcPairAddr​ ​=​ ​await​ ​CFactory​.​getPair​(​HBTC​.​address​)​; 
 ​            ​let​ ​HBTCPair​ ​=​ ​await​ ​CoFiXPair​.​at​(​hbtcPairAddr​)​; 
 ​            ​usdtInUSDTPool​ ​=​ ​await​ ​USDT​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​wethInUSDTPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​hbtcInHBTCTPool​ ​=​ ​await​ ​HBTC​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​wethInHBTCPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​let​ ​_liquidityUSDTPair​ ​=​ ​await​ ​USDTPair​.​balanceOf​(​LP​)​; 
 ​            ​let​ ​_liquidityHBTCPair​ ​=​ ​await​ ​HBTCPair​.​balanceOf​(​LP​)​; 
 ​            ​ethUserBalance​ ​=​ ​await​ ​web3​.​utils​.​fromWei​(​await​ ​web3​.​eth​.​getBalance​(​trader​)​,​ ​'ether'​) 
 ​            ​usdtUserBalance​ ​=​ ​await​ ​USDT​.​balanceOf​(​trader​)​; 
 ​            ​hbtcUserBalance​ ​=​ ​await​ ​HBTC​.​balanceOf​(​trader​)​; 
 ​            ​console​.​log​(​"------------addLiquidity for HBTC/ETH------------"​)​; 
 ​            ​console​.​log​(​"receipt.gasUsed:"​,​ ​result​.​receipt​.​gasUsed​)​; 
 ​            ​console​.​log​(​"USDT pool balance USDT:"​,​ ​usdtInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"USDT pool balance WETH:"​,​ ​wethInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance HBTC:"​,​ ​hbtcInHBTCTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance WETH:"​,​ ​wethInHBTCPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/USDT liquidity of LP:"​,​ ​_liquidityUSDTPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/HBTC liquidity of LP:"​,​ ​_liquidityHBTCPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance ETH:"​,​ ​ethUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance USDT:"​,​ ​usdtUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance HBTC:"​,​ ​hbtcUserBalance​.​toString​(​)​)​; 
 ​            ​// swapExactTokensForETH 
 ​            ​// - address token, 
 ​            ​// - uint amountIn, 
 ​            ​// - uint amountOutMin, 
 ​            ​// - address to, 
 ​            ​// - uint deadline 
 ​            ​let​ ​_amountIn​ ​=​ ​"100000000"​; 
 ​            ​_msgValue​ ​=​ ​web3​.​utils​.​toWei​(​'1.1'​,​ ​'ether'​)​; 
 ​            ​result​ ​=​ ​await​ ​CRouter​.​swapExactTokensForETH​(​USDT​.​address​,​ ​_amountIn​,​ ​0​,​ ​trader​,​ ​trader​,​ ​"99999999999"​,​ ​{​ ​from​: ​trader​,​ ​value​: ​_msgValue​ ​}​)​; 
 ​            ​console​.​log​(​"------------swapExactTokensForETH------------"​)​; 
 ​            ​usdtInUSDTPool​ ​=​ ​await​ ​USDT​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​wethInUSDTPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​hbtcInHBTCTPool​ ​=​ ​await​ ​HBTC​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​wethInHBTCPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​_liquidityUSDTPair​ ​=​ ​await​ ​USDTPair​.​balanceOf​(​LP​)​; 
 ​            ​_liquidityHBTCPair​ ​=​ ​await​ ​HBTCPair​.​balanceOf​(​LP​)​; 
 ​            ​ethUserBalance​ ​=​ ​await​ ​web3​.​utils​.​fromWei​(​await​ ​web3​.​eth​.​getBalance​(​trader​)​,​ ​'ether'​) 
 ​            ​usdtUserBalance​ ​=​ ​await​ ​USDT​.​balanceOf​(​trader​)​; 
 ​            ​hbtcUserBalance​ ​=​ ​await​ ​HBTC​.​balanceOf​(​trader​)​; 
 ​            ​console​.​log​(​"receipt.gasUsed:"​,​ ​result​.​receipt​.​gasUsed​)​; 
 ​            ​console​.​log​(​"USDT pool balance USDT:"​,​ ​usdtInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"USDT pool balance WETH:"​,​ ​wethInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance HBTC:"​,​ ​hbtcInHBTCTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance WETH:"​,​ ​wethInHBTCPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/USDT liquidity of LP:"​,​ ​_liquidityUSDTPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/HBTC liquidity of LP:"​,​ ​_liquidityHBTCPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance ETH:"​,​ ​ethUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance USDT:"​,​ ​usdtUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance HBTC:"​,​ ​hbtcUserBalance​.​toString​(​)​)​; 
  
 ​            ​// swapExactETHForTokens 
 ​            ​// - address token, 
 ​            ​// - uint amountIn, 
 ​            ​// - uint amountOutMin, 
 ​            ​// - address to, 
 ​            ​// - uint deadline 
 ​            ​_amountIn​ ​=​ ​web3​.​utils​.​toWei​(​'0.2'​,​ ​'ether'​)​; 
 ​            ​_msgValue​ ​=​ ​web3​.​utils​.​toWei​(​'0.3'​,​ ​'ether'​)​; 
 ​            ​result​ ​=​ ​await​ ​CRouter​.​swapExactETHForTokens​(​USDT​.​address​,​ ​_amountIn​,​ ​0​,​ ​trader​,​ ​trader​,​ ​"99999999999"​,​ ​{​ ​from​: ​trader​,​ ​value​: ​_msgValue​ ​}​)​; 
 ​            ​console​.​log​(​"------------swapExactETHForTokens------------"​)​; 
 ​            ​usdtInUSDTPool​ ​=​ ​await​ ​USDT​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​wethInUSDTPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​hbtcInHBTCTPool​ ​=​ ​await​ ​HBTC​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​wethInHBTCPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​_liquidityUSDTPair​ ​=​ ​await​ ​USDTPair​.​balanceOf​(​LP​)​; 
 ​            ​_liquidityHBTCPair​ ​=​ ​await​ ​HBTCPair​.​balanceOf​(​LP​)​; 
 ​            ​ethUserBalance​ ​=​ ​await​ ​web3​.​utils​.​fromWei​(​await​ ​web3​.​eth​.​getBalance​(​trader​)​,​ ​'ether'​) 
 ​            ​usdtUserBalance​ ​=​ ​await​ ​USDT​.​balanceOf​(​trader​)​; 
 ​            ​hbtcUserBalance​ ​=​ ​await​ ​HBTC​.​balanceOf​(​trader​)​; 
 ​            ​console​.​log​(​"receipt.gasUsed:"​,​ ​result​.​receipt​.​gasUsed​)​; 
 ​            ​console​.​log​(​"USDT pool balance USDT:"​,​ ​usdtInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"USDT pool balance WETH:"​,​ ​wethInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance HBTC:"​,​ ​hbtcInHBTCTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance WETH:"​,​ ​wethInHBTCPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/USDT liquidity of LP:"​,​ ​_liquidityUSDTPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/HBTC liquidity of LP:"​,​ ​_liquidityHBTCPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance ETH:"​,​ ​ethUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance USDT:"​,​ ​usdtUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance HBTC:"​,​ ​hbtcUserBalance​.​toString​(​)​)​; 
  
 ​            ​// setTheta 
 ​            ​const​ ​theta​ ​=​ ​new​ ​BN​(​10​)​; 
 ​            ​await​ ​CoFiXCtrl​.​setTheta​(​USDT​.​address​,​ ​theta​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
 ​            ​let​ ​kInfo​ ​=​ ​await​ ​CoFiXCtrl​.​getKInfo​(​USDT​.​address​)​; 
 ​            ​expect​(​kInfo​.​theta​)​.​to​.​bignumber​.​equal​(​theta​)​; 
  
 ​            ​// swapExactTokensForTokens 
 ​            ​// - address tokenIn, 
 ​            ​// - address tokenOut, 
 ​            ​// - uint amountIn, 
 ​            ​// - uint amountOutMin, 
 ​            ​// - address to, 
 ​            ​// - uint deadline 
 ​            ​// USDT -> HBTC 
 ​            ​_amountIn​ ​=​ ​"100000000"​; 
 ​            ​_msgValue​ ​=​ ​web3​.​utils​.​toWei​(​'0.1'​,​ ​'ether'​)​; 
 ​            ​// get price now from NEST3PriceOracleMock Contract 
 ​            ​let​ ​p​ ​=​ ​await​ ​PriceOracle​.​checkPriceNow​(​USDT​.​address​)​; 
 ​            ​console​.​log​(​"price now> ethAmount:"​,​ ​p​.​ethAmount​.​toString​(​)​,​ ​", erc20Amount:"​,​ ​p​.​erc20Amount​.​toString​(​)​,​ ​p​.​erc20Amount​.​mul​(​new​ ​BN​(​web3​.​utils​.​toWei​(​'1'​,​ ​'ether'​)​)​)​.​div​(​p​.​ethAmount​)​.​div​(​new​ ​BN​(​'1000000'​)​)​.​toString​(​)​,​ ​"USDT/ETH"​)​; 
 ​            ​result​ ​=​ ​await​ ​CRouter​.​swapExactTokensForTokens​(​USDT​.​address​,​ ​HBTC​.​address​,​ ​_amountIn​,​ ​0​,​ ​trader​,​ ​trader​,​ ​"99999999999"​,​ ​{​ ​from​: ​trader​,​ ​value​: ​_msgValue​ ​}​)​; 
 ​            ​console​.​log​(​"------------swapExactTokensForTokens------------"​)​; 
 ​            ​usdtInUSDTPool​ ​=​ ​await​ ​USDT​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​wethInUSDTPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​hbtcInHBTCTPool​ ​=​ ​await​ ​HBTC​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​wethInHBTCPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​_liquidityUSDTPair​ ​=​ ​await​ ​USDTPair​.​balanceOf​(​LP​)​; 
 ​            ​_liquidityHBTCPair​ ​=​ ​await​ ​HBTCPair​.​balanceOf​(​LP​)​; 
 ​            ​ethUserBalance​ ​=​ ​await​ ​web3​.​utils​.​fromWei​(​await​ ​web3​.​eth​.​getBalance​(​trader​)​,​ ​'ether'​) 
 ​            ​usdtUserBalance​ ​=​ ​await​ ​USDT​.​balanceOf​(​trader​)​; 
 ​            ​hbtcUserBalance​ ​=​ ​await​ ​HBTC​.​balanceOf​(​trader​)​; 
 ​            ​// console.log("tx result:", result); 
 ​            ​console​.​log​(​"receipt.gasUsed:"​,​ ​result​.​receipt​.​gasUsed​)​; 
 ​            ​console​.​log​(​"USDT pool balance USDT:"​,​ ​usdtInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"USDT pool balance WETH:"​,​ ​wethInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance HBTC:"​,​ ​hbtcInHBTCTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance WETH:"​,​ ​wethInHBTCPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/USDT liquidity of LP:"​,​ ​_liquidityUSDTPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/HBTC liquidity of LP:"​,​ ​_liquidityHBTCPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance ETH:"​,​ ​ethUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance USDT:"​,​ ​usdtUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance HBTC:"​,​ ​hbtcUserBalance​.​toString​(​)​)​; 
 ​            ​// check if fee receiver get the fee reward 
 ​            ​let​ ​feeReceiver​ ​=​ ​await​ ​CFactory​.​getFeeReceiver​(​)​; 
 ​            ​let​ ​wethInFeeReceiver​ ​=​ ​await​ ​WETH​.​balanceOf​(​feeReceiver​)​; 
 ​            ​console​.​log​(​"WETH balance in feeReceiver:"​,​ ​wethInFeeReceiver​.​toString​(​)​,​ ​", feeReceiver:"​,​ ​feeReceiver​)​; 
 ​            ​expect​(​wethInFeeReceiver​)​.​to​.​bignumber​.​equal​(​"0"​)​;​ ​// if not setTradeMiningStatus, the trading fee is kept in pool 
  
 ​            ​// setTradeMiningStatus 
 ​            ​await​ ​CFactory​.​setTradeMiningStatus​(​USDT​.​address​,​ ​true​)​; 
  
 ​            ​// swap again after we setTradeMiningStatus to true 
 ​            ​await​ ​CRouter​.​swapExactTokensForTokens​(​USDT​.​address​,​ ​HBTC​.​address​,​ ​_amountIn​,​ ​0​,​ ​trader​,​ ​trader​,​ ​"99999999999"​,​ ​{​ ​from​: ​trader​,​ ​value​: ​_msgValue​ ​}​)​; 
 ​            ​wethInFeeReceiver​ ​=​ ​await​ ​WETH​.​balanceOf​(​feeReceiver​)​;​ ​// not zero this time 
 ​            ​kInfo​ ​=​ ​await​ ​CoFiXCtrl​.​getKInfo​(​USDT​.​address​)​; 
 ​            ​let​ ​k_base​ ​=​ ​await​ ​CoFiXCtrl​.​K_BASE​(​)​;​  
 ​            ​console​.​log​(​"kInfo> k:"​,​ ​kInfo​.​k​.​toString​(​)​,​ ​"("​,​ ​kInfo​.​k​.​toString​(​)​ ​/​ ​k_base​.​toString​(​)​,​ ​")"​,​ ​", updatedAt:"​,​ ​kInfo​.​updatedAt​.​toString​(​)​)​; 
 ​            ​// get the latest k info from CoFiXController contract, including k value & last updated time 
 ​            ​// fee = amountIn.mul(_op.ethAmount).mul(K_BASE).mul(_op.theta).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE); 
 ​            ​const​ ​THETA_BASE​ ​=​ ​"1E8"​; 
 ​            ​const​ ​expectedFee​ ​=​ ​Decimal​(​_amountIn​)​.​mul​(​Decimal​(​p​.​ethAmount​.​toString​(​)​)​)​.​mul​(​Decimal​(​k_base​.​toString​(​)​)​)​.​mul​(​Decimal​(​theta​.​toString​(​)​)​)​.​div​(​Decimal​(​p​.​erc20Amount​.​toString​(​)​)​)​.​div​(​Decimal​(​k_base​.​toString​(​)​)​.​add​(​Decimal​(​kInfo​.​k​.​toString​(​)​)​)​)​.​div​(​Decimal​(​THETA_BASE​)​)​; 
 ​            ​console​.​log​(​`expectedFee: ​${​expectedFee​.​toString​(​)​}​, calculatedFee: ​${​wethInFeeReceiver​.​toString​(​)​}​`​)​; 
 ​            ​let​ ​error​ ​=​ ​calcRelativeDiff​(​expectedFee​,​ ​wethInFeeReceiver​.​toString​(​)​)​; 
 ​            ​console​.​log​(​`expected: ​${​expectedFee​}​, actual:​${​wethInFeeReceiver​}​, error:​${​error​}​`​)​; 
 ​            ​assert​.​isAtMost​(​error​.​toNumber​(​)​,​ ​errorDelta​)​; 
  
 ​            ​// removeLiquidityGetETH 
 ​            ​// - address token, 
 ​            ​// - uint liquidity, 
 ​            ​// - uint amountETHMin, 
 ​            ​// - address to, 
 ​            ​// - uint deadline 
 ​            ​// approve liquidity to router 
 ​            ​await​ ​USDTPair​.​approve​(​CRouter​.​address​,​ ​liquidityUSDTPair​,​ ​{​ ​from​: ​LP​ ​}​)​; 
 ​            ​let​ ​partLiquidity​ ​=​ ​liquidityUSDTPair​.​div​(​new​ ​web3​.​utils​.​BN​(​'5'​)​)​; 
 ​            ​_msgValue​ ​=​ ​web3​.​utils​.​toWei​(​'0.1'​,​ ​'ether'​)​; 
 ​            ​result​ ​=​ ​await​ ​CRouter​.​removeLiquidityGetETH​(​USDT​.​address​,​ ​partLiquidity​,​ ​0​,​ ​LP​,​ ​"99999999999"​,​ ​{​ ​from​: ​LP​,​ ​value​: ​_msgValue​ ​}​)​; 
 ​            ​console​.​log​(​"------------removeLiquidityGetETH------------"​)​; 
 ​            ​usdtInUSDTPool​ ​=​ ​await​ ​USDT​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​wethInUSDTPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​hbtcInHBTCTPool​ ​=​ ​await​ ​HBTC​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​wethInHBTCPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​_liquidityUSDTPair​ ​=​ ​await​ ​USDTPair​.​balanceOf​(​LP​)​; 
 ​            ​_liquidityHBTCPair​ ​=​ ​await​ ​HBTCPair​.​balanceOf​(​LP​)​; 
 ​            ​ethUserBalance​ ​=​ ​await​ ​web3​.​utils​.​fromWei​(​await​ ​web3​.​eth​.​getBalance​(​LP​)​,​ ​'ether'​) 
 ​            ​usdtUserBalance​ ​=​ ​await​ ​USDT​.​balanceOf​(​LP​)​; 
 ​            ​hbtcUserBalance​ ​=​ ​await​ ​HBTC​.​balanceOf​(​LP​)​; 
 ​            ​console​.​log​(​"receipt.gasUsed:"​,​ ​result​.​receipt​.​gasUsed​)​; 
 ​            ​console​.​log​(​"USDT pool balance USDT:"​,​ ​usdtInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"USDT pool balance WETH:"​,​ ​wethInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance HBTC:"​,​ ​hbtcInHBTCTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance WETH:"​,​ ​wethInHBTCPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/USDT liquidity of LP:"​,​ ​_liquidityUSDTPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/HBTC liquidity of LP:"​,​ ​_liquidityHBTCPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance ETH:"​,​ ​ethUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance USDT:"​,​ ​usdtUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance HBTC:"​,​ ​hbtcUserBalance​.​toString​(​)​)​; 
  
 ​            ​// removeLiquidityGetToken 
 ​            ​// - address token, 
 ​            ​// - uint liquidity, 
 ​            ​// - uint amountTokenMin, 
 ​            ​// - address to, 
 ​            ​// - uint deadline 
 ​            ​let​ ​mostLeftLiquidity​ ​=​ ​liquidityUSDTPair​.​mul​(​new​ ​web3​.​utils​.​BN​(​'3'​)​)​.​div​(​new​ ​web3​.​utils​.​BN​(​'5'​)​)​; 
 ​            ​_msgValue​ ​=​ ​web3​.​utils​.​toWei​(​'0.1'​,​ ​'ether'​)​; 
 ​            ​result​ ​=​ ​await​ ​CRouter​.​removeLiquidityGetToken​(​USDT​.​address​,​ ​mostLeftLiquidity​,​ ​0​,​ ​LP​,​ ​"99999999999"​,​ ​{​ ​from​: ​LP​,​ ​value​: ​_msgValue​ ​}​)​; 
 ​            ​console​.​log​(​"------------removeLiquidityGetToken------------"​)​; 
 ​            ​usdtInUSDTPool​ ​=​ ​await​ ​USDT​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​wethInUSDTPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​hbtcInHBTCTPool​ ​=​ ​await​ ​HBTC​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​wethInHBTCPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​hbtcPairAddr​)​; 
 ​            ​_liquidityUSDTPair​ ​=​ ​await​ ​USDTPair​.​balanceOf​(​LP​)​; 
 ​            ​_liquidityHBTCPair​ ​=​ ​await​ ​HBTCPair​.​balanceOf​(​LP​)​; 
 ​            ​ethUserBalance​ ​=​ ​await​ ​web3​.​utils​.​fromWei​(​await​ ​web3​.​eth​.​getBalance​(​LP​)​,​ ​'ether'​) 
 ​            ​usdtUserBalance​ ​=​ ​await​ ​USDT​.​balanceOf​(​LP​)​; 
 ​            ​hbtcUserBalance​ ​=​ ​await​ ​HBTC​.​balanceOf​(​LP​)​; 
 ​            ​console​.​log​(​"receipt.gasUsed:"​,​ ​result​.​receipt​.​gasUsed​)​; 
 ​            ​console​.​log​(​"USDT pool balance USDT:"​,​ ​usdtInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"USDT pool balance WETH:"​,​ ​wethInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance HBTC:"​,​ ​hbtcInHBTCTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"HBTC pool balance WETH:"​,​ ​wethInHBTCPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/USDT liquidity of LP:"​,​ ​_liquidityUSDTPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"ETH/HBTC liquidity of LP:"​,​ ​_liquidityHBTCPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance ETH:"​,​ ​ethUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance USDT:"​,​ ​usdtUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance HBTC:"​,​ ​hbtcUserBalance​.​toString​(​)​)​; 
 ​        ​}​)​; 
  
 ​        ​it​(​"should addPool correctly"​,​ ​async​ ​(​)​ ​=>​ ​{ 
 ​            ​let​ ​usdtPairAddr​ ​=​ ​await​ ​CFactory​.​getPair​(​USDT​.​address​)​; 
 ​            ​let​ ​USDTPair​ ​=​ ​await​ ​CoFiXPair​.​at​(​usdtPairAddr​)​; 
 ​            ​const​ ​StakingRewards​ ​=​ ​await​ ​CoFiXStakingRewards​.​new​(​CoFi​.​address​,​ ​USDTPair​.​address​,​ ​CFactory​.​address​,​ ​{​ ​from​: ​deployer​ ​}​)​; 
  
 ​            ​await​ ​VaultForLP​.​addPool​(​StakingRewards​.​address​,​ ​{​from​: ​deployer​}​)​; 
 ​            ​const​ ​poolInfo​ ​=​ ​await​ ​VaultForLP​.​getPoolInfo​(​StakingRewards​.​address​)​; 
 ​            ​expect​(​poolInfo​.​state​)​.​to​.​bignumber​.​equal​(​POOL_STATE_ENABLED​)​; 
 ​            ​expect​(​poolInfo​.​weight​)​.​to​.​bignumber​.​equal​(​"0"​)​;​ ​// default weight 
 ​            ​const​ ​stakingPool​ ​=​ ​await​ ​VaultForLP​.​stakingPoolForPair​(​USDTPair​.​address​)​; 
 ​            ​expect​(​stakingPool​)​.​equal​(​StakingRewards​.​address​)​; 
 ​        ​}​)​; 
  
 ​        ​it​(​"should addLiquidityAndStake correctly"​,​ ​async​ ​(​)​ ​=>​ ​{ 
 ​            ​let​ ​usdtPairAddr​ ​=​ ​await​ ​CFactory​.​getPair​(​USDT​.​address​)​; 
 ​            ​let​ ​USDTPair​ ​=​ ​await​ ​CoFiXPair​.​at​(​usdtPairAddr​)​; 
 ​            ​const​ ​stakingPool​ ​=​ ​await​ ​VaultForLP​.​stakingPoolForPair​(​USDTPair​.​address​)​; 
 ​            ​const​ ​StakingRewards​ ​=​ ​await​ ​CoFiXStakingRewards​.​at​(​stakingPool​)​; 
  
 ​            ​let​ ​_amountETH​ ​=​ ​web3​.​utils​.​toWei​(​'1'​,​ ​'ether'​)​; 
 ​            ​let​ ​_msgValue​ ​=​ ​web3​.​utils​.​toWei​(​'1.1'​,​ ​'ether'​)​; 
 ​            ​let​ ​_amountToken​ ​=​ ​"1000000000"​; 
 ​            ​let​ ​result​ ​=​ ​await​ ​CRouter​.​addLiquidityAndStake​(​USDT​.​address​,​ ​_amountETH​,​ ​_amountToken​,​ ​0​,​ ​LP​,​ ​"99999999999"​,​ ​{​ ​from​: ​LP​,​ ​value​: ​_msgValue​ ​}​)​; 
  
 ​            ​console​.​log​(​"------------addLiquidityAndStake for USDT/ETH------------"​)​; 
 ​            ​let​ ​liquidityUSDTPair​ ​=​ ​await​ ​USDTPair​.​balanceOf​(​LP​)​; 
 ​            ​let​ ​usdtInUSDTPool​ ​=​ ​await​ ​USDT​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​let​ ​wethInUSDTPool​ ​=​ ​await​ ​WETH​.​balanceOf​(​usdtPairAddr​)​; 
 ​            ​let​ ​ethUserBalance​ ​=​ ​await​ ​web3​.​utils​.​fromWei​(​await​ ​web3​.​eth​.​getBalance​(​LP​)​,​ ​'ether'​) 
 ​            ​let​ ​usdtUserBalance​ ​=​ ​await​ ​USDT​.​balanceOf​(​LP​)​; 
 ​            ​let​ ​hbtcUserBalance​ ​=​ ​await​ ​HBTC​.​balanceOf​(​LP​)​; 
 ​            ​console​.​log​(​"receipt.gasUsed:"​,​ ​result​.​receipt​.​gasUsed​)​; 
 ​            ​console​.​log​(​"pool balance USDT:"​,​ ​usdtInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"pool balance WETH:"​,​ ​wethInUSDTPool​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"got liquidity ETH/USDT:"​,​ ​liquidityUSDTPair​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance ETH:"​,​ ​ethUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance USDT:"​,​ ​usdtUserBalance​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"user balance HBTC:"​,​ ​hbtcUserBalance​.​toString​(​)​)​; 
  
 ​            ​const​ ​balanceInStake​ ​=​ ​await​ ​StakingRewards​.​balanceOf​(​LP​)​; 
 ​            ​const​ ​totalSupply​ ​=​ ​await​ ​StakingRewards​.​totalSupply​(​)​; 
 ​            ​console​.​log​(​"staking> balanceInStake:"​,​ ​balanceInStake​.​toString​(​)​)​; 
 ​            ​console​.​log​(​"staking> pool totalSupply:"​,​ ​totalSupply​.​toString​(​)​)​; 
 ​        ​}​)​; 
 ​    ​}​)​; 
  
  
 ​    ​describe​(​'Read from contract'​,​ ​function​ ​(​)​ ​{ 
 ​        ​it​(​"test"​,​ ​async​ ​(​)​ ​=>​ ​{ 
 ​            ​// get K_BASE from CoFiXController contract 
 ​            ​let​ ​k_base​ ​=​ ​await​ ​CoFiXCtrl​.​K_BASE​(​)​;​ ​// 1E8 
 ​            ​expect​(​k_base​)​.​to​.​bignumber​.​equal​(​new​ ​BN​(​1E8​)​)​; 
  
 ​            ​// get pair address 
 ​            ​let​ ​usdtPairAddr​ ​=​ ​await​ ​CFactory​.​getPair​(​USDT​.​address​)​; 
 ​            ​let​ ​USDTPair​ ​=​ ​await​ ​CoFiXPair​.​at​(​usdtPairAddr​)​; 
  
 ​            ​// get NAVPS_BASE from CoFiXPair contract 
 ​            ​let​ ​navps_base​ ​=​ ​await​ ​USDTPair​.​NAVPS_BASE​(​)​; 
 ​            ​expect​(​navps_base​)​.​to​.​bignumber​.​equal​(​(​new​ ​BN​(​'10'​)​)​.​pow​(​new​ ​BN​(​18​)​)​)​; 
  
 ​            ​// get the latest k info from CoFiXController contract, including k value & last updated time 
 ​            ​let​ ​kInfo​ ​=​ ​await​ ​CoFiXCtrl​.​getKInfo​(​USDT​.​address​)​; 
 ​            ​console​.​log​(​"kInfo> k:"​,​ ​kInfo​.​k​.​toString​(​)​,​ ​"("​,​ ​kInfo​.​k​.​toString​(​)​ ​/​ ​k_base​.​toString​(​)​,​ ​")"​,​ ​", updatedAt:"​,​ ​kInfo​.​updatedAt​.​toString​(​)​)​; 
  
 ​            ​// get price now from NEST3PriceOracleMock Contract 
 ​            ​let​ ​p​ ​=​ ​await​ ​PriceOracle​.​checkPriceNow​(​USDT​.​address​)​; 
 ​            ​console​.​log​(​"price now> ethAmount:"​,​ ​p​.​ethAmount​.​toString​(​)​,​ ​", erc20Amount:"​,​ ​p​.​erc20Amount​.​toString​(​)​,​ ​p​.​erc20Amount​.​mul​(​new​ ​BN​(​web3​.​utils​.​toWei​(​'1'​,​ ​'ether'​)​)​)​.​div​(​p​.​ethAmount​)​.​div​(​new​ ​BN​(​'1000000'​)​)​.​toString​(​)​,​ ​"USDT/ETH"​)​; 
  
 ​            ​// get Net Asset Value Per Share for USDTPair contract 
 ​            ​let​ ​oraclePrice​ ​=​ ​[​p​.​ethAmount​,​ ​p​.​erc20Amount​,​ ​new​ ​BN​(​"0"​)​,​ ​kInfo​.​k​,​ ​new​ ​BN​(​"0"​)​]​; 
  
 ​            ​let​ ​navpsForMint​ ​=​ ​await​ ​USDTPair​.​getNAVPerShareForMint​(​oraclePrice​)​; 
  
 ​            ​let​ ​navps_value_for_mint​ ​=​ ​(​Decimal​(​navpsForMint​.​toString​(​)​)​)​.​div​(​Decimal​(​navps_base​.​toString​(​)​)​)​; 
 ​            ​console​.​log​(​"net asset value per share for mint:"​,​ ​navps_value_for_mint​)​; 
  
 ​            ​const​ ​expected​ ​=​ ​"1"​; 
 ​            ​let​ ​errorMint​ ​=​ ​calcRelativeDiff​(​expected​,​ ​navps_value_for_mint​.​toString​(​)​)​; 
 ​            ​console​.​log​(​`navps_value_for_mint> expected: ​${​expected​}​, actual: ​${​navps_value_for_mint​.​toString​(​)​}​, error: ​${​errorMint​}​`​)​; 
 ​            ​assert​.​isAtMost​(​errorMint​.​toNumber​(​)​,​ ​10​ ​**​ ​-​1​)​; 
  
 ​            ​let​ ​navpsForBurn​ ​=​ ​await​ ​USDTPair​.​getNAVPerShareForBurn​(​oraclePrice​)​; 
 ​            ​let​ ​navps_value_for_burn​ ​=​ ​(​Decimal​(​navpsForBurn​.​toString​(​)​)​)​.​div​(​Decimal​(​navps_base​.​toString​(​)​)​)​; 
 ​            ​// let navps_value_for_burn = navpsForBurn.toNumber() / navps_base.toNumber(); 
 ​            ​console​.​log​(​"net asset value per share for burn:"​,​ ​navps_value_for_burn​)​; 
  
 ​            ​let​ ​errorBurn​ ​=​ ​calcRelativeDiff​(​expected​,​ ​navps_value_for_burn​.​toString​(​)​)​; 
 ​            ​console​.​log​(​`navps_value_for_burn> expected: ​${​expected​}​, actual: ​${​navps_value_for_burn​.​toString​(​)​}​, error: ​${​errorBurn​}​`​)​; 
 ​            ​assert​.​isAtMost​(​errorBurn​.​toNumber​(​)​,​ ​10​ ​**​ ​-​1​)​; 
  
 ​            ​expect​(​errorMint​.​toString​(​)​)​.​to​.​bignumber​.​above​(​errorBurn​.​toString​(​)​)​; 
  
 ​            ​// get total liquidity (totalSupply of pair/pool token) 
 ​            ​let​ ​totalLiquidity​ ​=​ ​await​ ​USDTPair​.​totalSupply​(​)​; 
 ​            ​console​.​log​(​"total liquidity of WETH/USDT pool:"​,​ ​totalLiquidity​.​toString​(​)​)​; 
  
 ​            ​// estimate liquidity for addLiquidity() function in router 
 ​            ​// get estimated liquidity amount (it represents the amount of pool tokens will be minted if someone provide liquidity to the pool) 
 ​            ​let​ ​amount0​ ​=​ ​web3​.​utils​.​toWei​(​'1'​,​ ​'ether'​)​;​ ​// ethAmount 
 ​            ​let​ ​amount1​ ​=​ ​new​ ​BN​(​"500000000"​)​;​ ​// erc20Amount 
 ​            ​let​ ​liquidity​ ​=​ ​await​ ​USDTPair​.​getLiquidity​(​amount0​,​ ​amount1​,​ ​oraclePrice​)​; 
 ​            ​console​.​log​(​"estimate addLiquidity> liquidity:"​,​ ​liquidity​.​toString​(​)​,​ ​", ratio:"​,​ ​liquidity​.​toString​(​)​ ​/​ ​totalLiquidity​.​toString​(​)​)​; 
  
 ​            ​// estimate amountOut for removeLiquidityGetETH() function in router 
 ​            ​// calc amountOut for token0 (WETH) when send liquidity token to pool for burning 
 ​            ​let​ ​result​ ​=​ ​await​ ​USDTPair​.​calcOutToken0ForBurn​(​liquidity​,​ ​oraclePrice​)​; 
 ​            ​console​.​log​(​"estimate removeLiquidityGetETH> amountOutETH:"​,​ ​result​.​amountOut​.​toString​(​)​,​ ​web3​.​utils​.​fromWei​(​result​.​amountOut​,​ ​'ether'​)​,​ ​"ETH"​)​; 
  
 ​            ​// estimate amountOut for removeLiquidityGetToken() function in router 
 ​            ​// calc amountOut for token1 (ERC20 token) when send liquidity token to pool for burning 
 ​            ​result​ ​=​ ​await​ ​USDTPair​.​calcOutToken1ForBurn​(​liquidity​,​ ​oraclePrice​)​; 
 ​            ​console​.​log​(​"estimate removeLiquidityGetToken> amountOutETH:"​,​ ​result​.​amountOut​.​toString​(​)​,​ ​result​.​amountOut​.​div​(​new​ ​BN​(​'1000000'​)​)​.​toString​(​)​,​ ​"USDT"​)​; 
  
 ​            ​// estimate amountOut for swapExactETHForTokens() function in router 
 ​            ​// get estimated amountOut for token1 (ERC20 token) when swapWithExact 
 ​            ​let​ ​amountInETH​ ​=​ ​web3​.​utils​.​toWei​(​'1'​,​ ​'ether'​)​; 
 ​            ​result​ ​=​ ​await​ ​USDTPair​.​calcOutToken1​(​amountInETH​,​ ​oraclePrice​)​; 
 ​            ​console​.​log​(​"estimate swapExactETHForTokens> amountOutToken:"​,​ ​result​.​amountOut​.​toString​(​)​,​ ​result​.​amountOut​.​div​(​new​ ​BN​(​'1000000'​)​)​.​toString​(​)​,​ ​"USDT"​)​; 
  
 ​            ​// estimate amountOut for swapExactTokenForETH() function in router 
 ​            ​// get estimated amountOut for token0 (WETH) when swapWithExact 
 ​            ​amountInToken​ ​=​ ​new​ ​BN​(​"530000000"​)​; 
 ​            ​let​ ​calcOutToken0Result​ ​=​ ​await​ ​USDTPair​.​calcOutToken0​(​amountInToken​,​ ​oraclePrice​)​; 
 ​            ​console​.​log​(​"estimate swapExactTokenForETH> amountOutETH:"​,​ ​calcOutToken0Result​.​amountOut​.​toString​(​)​,​ ​web3​.​utils​.​fromWei​(​calcOutToken0Result​.​amountOut​,​ ​'ether'​)​,​ ​"ETH"​)​; 
  
 ​            ​// estimate amountIn for swapETHForExactTokens() function in router 
 ​            ​// get estimate amountInNeeded for token0 (WETH) when swapForExact 
 ​            ​result​ ​=​ ​await​ ​USDTPair​.​calcInNeededToken0​(​result​.​amountOut​,​ ​oraclePrice​)​; 
 ​            ​console​.​log​(​"estimate swapETHForExactTokens> amountInETHNeeded:"​,​ ​result​.​amountInNeeded​.​toString​(​)​,​ ​web3​.​utils​.​fromWei​(​result​.​amountInNeeded​,​ ​'ether'​)​,​ ​"ETH"​)​; 
  
  
 ​            ​// estimate amountIn for swapTokensForExactETH() function in router 
 ​            ​// get estimate amountInNeeded for token1 (ERC20 token) when swapForExact 
 ​            ​result​ ​=​ ​await​ ​USDTPair​.​calcInNeededToken1​(​calcOutToken0Result​.​amountOut​,​ ​oraclePrice​)​; 
 ​            ​// get estimate amountInNeeded for token0 (WETH) when swapForExact 
 ​            ​console​.​log​(​"estimate swapTokensForExactETH> amountInTokenNeeded:"​,​ ​result​.​amountInNeeded​.​toString​(​)​,​ ​result​.​amountInNeeded​.​div​(​new​ ​BN​(​'1000000'​)​)​.​toString​(​)​,​ ​"USDT"​)​; 
 ​        ​}​)​; 
 ​    ​}​)​; 
  
 ​}​)
ข้อเสนอการปรับปรุง Ethereum
📖 EIP นี้อยู่ในขั้นตอนการตรวจสอบ อาจมีการเปลี่ยนแปลงและยินดีรับคำติชม
EIP-1967: สล็อตจัดเก็บพร็อกซีมาตรฐาน 
สร้างมาตรฐานโดยที่ผู้รับมอบฉันทะจัดเก็บที่อยู่ของสัญญาลอจิกที่พวกเขามอบหมายให้ เช่นเดียวกับข้อมูลเฉพาะอื่นๆ ของพร็อกซี่
ผู้เขียน	ซานติอาโก พัลลาดิโน
กระดานสนทนา-ถึง	https://ethereum-magicians.org/t/eip-1967-standard-proxy-storage-slots/3185
สถานะ	ทบทวน
พิมพ์	รางมาตรฐาน
หมวดหมู่	ERC
สร้าง	2019-04-24
สารบัญ
เชิงนามธรรม
แรงจูงใจ
ข้อมูลจำเพาะ
ที่อยู่สัญญาลอจิก
ที่อยู่สัญญาบีคอน
ที่อยู่ผู้ดูแลระบบ
เหตุผล
การดำเนินการอ้างอิง
ข้อควรพิจารณาด้านความปลอดภัย
ลิขสิทธิ์
 เชิงนามธรรม
สัญญาตัวแทนมอบสิทธิ์ใช้กันอย่างแพร่หลายสำหรับทั้งความสามารถในการอัปเกรดและการประหยัดก๊าซ พร็อกซี่เหล่านี้อาศัยสัญญาตรรกะ (หรือที่เรียกว่าสัญญาการใช้งานหรือสำเนาหลัก) ที่เรียกว่าการใช้delegatecall. สิ่งนี้ทำให้พร็อกซี่สามารถคงสถานะคงอยู่ (ที่เก็บข้อมูลและความสมดุล) ในขณะที่รหัสถูกมอบหมายให้กับสัญญาลอจิก

เพื่อหลีกเลี่ยงความขัดแย้งในการใช้งานที่เก็บข้อมูลระหว่างพร็อกซี่และสัญญาลอจิก โดยทั่วไปที่อยู่ของสัญญาลอจิกจะถูกบันทึกไว้ในช่องจัดเก็บเฉพาะที่รับประกันว่าจะไม่ถูกจัดสรรโดยคอมไพเลอร์ EIP นี้เสนอชุดสล็อตมาตรฐานเพื่อเก็บข้อมูลพร็อกซี ซึ่งช่วยให้ลูกค้าเช่นนักสำรวจบล็อกสามารถดึงข้อมูลและแสดงข้อมูลนี้แก่ผู้ใช้ปลายทางได้อย่างเหมาะสม และให้สัญญาแบบลอจิกเพื่อดำเนินการกับข้อมูลดังกล่าว

 แรงจูงใจ
มีการใช้พร็อกซีการมอบสิทธิ์อย่างกว้างขวาง โดยเป็นวิธีการสนับสนุนการอัปเกรดและลดต้นทุนค่าแก๊สในการปรับใช้ ตัวอย่างของพร็อกซี่เหล่านี้พบได้ในOpenZeppelin Contracts , Terminal , Gnosis , AragonOS , Melonport , Limechain , WindingTree , Decentralandและอื่นๆ อีกมากมาย

อย่างไรก็ตาม การขาดอินเทอร์เฟซทั่วไปในการรับที่อยู่ตรรกะสำหรับพร็อกซี ทำให้ไม่สามารถสร้างเครื่องมือทั่วไปที่ดำเนินการกับข้อมูลนี้ได้

ตัวอย่างคลาสสิกของสิ่งนี้คือตัวสำรวจบล็อก ในที่นี้ ผู้ใช้ปลายทางต้องการโต้ตอบกับสัญญาตรรกะพื้นฐาน ไม่ใช่ตัวพร็อกซีเอง มีวิธีทั่วไปในการดึงที่อยู่สัญญาลอจิกจากพร็อกซี่ทำให้นักสำรวจบล็อกสามารถแสดง ABI ของสัญญาลอจิกและไม่ใช่ของพร็อกซี (ดูพร็อกซีนี้ นักสำรวจจะตรวจสอบการจัดเก็บสัญญาที่ช่องที่แตกต่างกันเพื่อกำหนด หากเป็นพร็อกซีจริง ซึ่งในกรณีนี้จะแสดงข้อมูลเกี่ยวกับทั้งพร็อกซีและสัญญาลอจิก

อีกตัวอย่างหนึ่งคือสัญญาลอจิกที่ดำเนินการตามข้อเท็จจริงที่ว่าพวกเขาจะถูกพร็อกซีอย่างชัดเจน นี้จะช่วยให้พวกเขาที่อาจก่อให้เกิดการปรับปรุงรหัสเป็นส่วนหนึ่งของการใช้เหตุผลของพวกเขาเช่นเดียวกับกรณีของยูนิเวอร์แซอัพเกรด Proxy มาตรฐาน (EIP1822) สล็อตที่เก็บข้อมูลทั่วไปอนุญาตให้ใช้กรณีเหล่านี้โดยไม่ขึ้นกับการใช้งานพร็อกซีเฉพาะที่ใช้

 ข้อมูลจำเพาะ
ข้อกำหนดหลักสำหรับสล็อตการจัดเก็บที่เลือกคือคอมไพเลอร์ต้องไม่เลือกช่องเหล่านี้เพื่อจัดเก็บตัวแปรสถานะสัญญาใดๆ มิฉะนั้น สัญญาลอจิกอาจเขียนทับข้อมูลนี้บนพร็อกซีโดยไม่ได้ตั้งใจเมื่อเขียนไปยังตัวแปรของตัวเอง

Solidityจับคู่ตัวแปรกับที่เก็บข้อมูลตามลำดับที่ประกาศ หลังจากที่ห่วงโซ่การสืบทอดสัญญาถูกทำให้เป็นเส้นตรง: ตัวแปรแรกถูกกำหนดให้กับช่องแรก และอื่นๆ ข้อยกเว้นคือค่าในอาร์เรย์และการแมปแบบไดนามิก ซึ่งจัดเก็บไว้ในแฮชของการต่อคีย์และสล็อตพื้นที่เก็บข้อมูล ทีมพัฒนา Solidity ได้ยืนยันว่ารูปแบบการจัดเก็บข้อมูลจะได้รับการเก็บรักษาไว้ในเวอร์ชันใหม่ Vyper ดูเหมือนว่าจะเป็นไปตามกลยุทธ์เดียวกับความแข็งแรง โปรดทราบว่าสัญญาที่เขียนในภาษาอื่นหรือโดยตรงในการชุมนุม อาจมีการปะทะกัน

ด้วยเหตุนี้ ช่องเก็บข้อมูลที่เสนอสำหรับข้อมูลเฉพาะของพร็อกซีจึงมีดังต่อไปนี้ พวกมันถูกเลือกในลักษณะนี้ ดังนั้นจึงรับประกันได้ว่าจะไม่ขัดแย้งกับตัวแปรสถานะที่คอมไพเลอร์จัดสรร เนื่องจากพวกมันขึ้นอยู่กับแฮชของสตริงที่ไม่ได้ขึ้นต้นด้วยดัชนีหน่วยเก็บข้อมูล นอกจากนี้ ยังมีการ-1เพิ่มออฟเซ็ตเพื่อไม่ให้ทราบ preimage ของแฮช ซึ่งช่วยลดโอกาสการโจมตีที่อาจเกิดขึ้นได้

สามารถเพิ่มช่องเพิ่มเติมสำหรับข้อมูลเพิ่มเติมใน ERC ที่ตามมาได้ตามต้องการ

การตรวจสอบพร็อกซีมีความสำคัญต่อความปลอดภัยของแอปพลิเคชันจำนวนมาก ดังนั้นจึงจำเป็นที่จะต้องมีความสามารถในการติดตามการเปลี่ยนแปลงในการใช้งานและช่องผู้ดูแลระบบ ขออภัย การติดตามการเปลี่ยนแปลงช่องเก็บของไม่ใช่เรื่องง่าย ดังนั้น ขอแนะนำว่าฟังก์ชันใดๆ ที่เปลี่ยนแปลงสล็อตเหล่านี้ควรปล่อยเหตุการณ์ที่เกี่ยวข้องด้วย ซึ่งรวมถึงการเริ่มต้นจาก0x0ค่าแรกที่ไม่ใช่ศูนย์

 ที่อยู่สัญญาลอจิก
ช่องเก็บของ0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc (ได้รับเป็นbytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1))

มีที่อยู่ของสัญญาตรรกะที่พร็อกซีนี้มอบหมายให้ ควรว่างเปล่าหากใช้บีคอนแทน การเปลี่ยนแปลงในช่องนี้ควรได้รับแจ้งจากกิจกรรม:

event Upgraded(address indexed implementation);
 ที่อยู่สัญญาบีคอน
ช่องเก็บของ0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50(ได้รับเป็นbytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))

ถือที่อยู่ของสัญญาบีคอนที่พร็อกซีนี้อาศัย (ทางเลือก) ควรว่างเปล่าหากใช้ที่อยู่ตรรกะโดยตรงแทน และควรพิจารณาเฉพาะเมื่อช่องสัญญาตรรกะว่างเปล่า การเปลี่ยนแปลงในช่องนี้ควรได้รับแจ้งจากกิจกรรม:

event BeaconUpgraded(address indexed beacon);
บีคอนใช้สำหรับเก็บที่อยู่ลอจิกสำหรับพรอกซีหลายตัวในที่เดียว ทำให้สามารถอัพเกรดพร็อกซีหลายตัวได้โดยการแก้ไขสล็อตที่เก็บข้อมูลเดียว สัญญาบีคอนต้องใช้งานฟังก์ชัน:

function implementation() returns (address)
สัญญาพร็อกซีที่ใช้บีคอนจะไม่ใช้ช่องสัญญาแบบลอจิก แต่จะใช้ช่องสัญญาบีคอนเพื่อเก็บที่อยู่ของบีคอนที่ติดมาแทน หากต้องการทราบสัญญาตรรกะที่ใช้โดยพร็อกซีบีคอน ลูกค้าควร:

อ่านที่อยู่ของบีคอนสำหรับช่องเก็บข้อมูลลอจิกบีคอน
เรียกใช้implementation()ฟังก์ชันบนสัญญาบีคอน
The result of the implementation() function on the beacon contract SHOULD NOT depend on the caller (msg.sender).

 Admin address
Storage slot 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103 (obtained as bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)).

Holds the address that is allowed to upgrade the logic contract address for this proxy (optional). Changes to this slot SHOULD be notified by the event:

event AdminChanged(address previousAdmin, address newAdmin);
 Rationale
This EIP standardises the storage slot for the logic contract address, instead of a public method on the proxy contract as DelegateProxy (EIP897) does. The rationale for this is that proxies should never expose functions to end users that could potentially clash with those of the logic contract.

Note that a clash may occur even among functions with different names, since the ABI relies on just four bytes for the function selector. This can lead to unexpected errors, or even exploits, where a call to a proxied contract returns a different value than expected, since the proxy intercepts the call and answers with a value of its own.

From Malicious backdoors in Ethereum proxies by Nomic Labs:

Any function in the Proxy contract whose selector matches with one in the implementation contract will be called directly, completely skipping the implementation code.

Because the function selectors use a fixed amount of bytes, there will always be the possibility of a clash. This isn’t an issue for day to day development, given that the Solidity compiler will detect a selector clash within a contract, but this becomes exploitable when selectors are used for cross-contract interaction. Clashes can be abused to create a seemingly well-behaved contract that’s actually concealing a backdoor.

The fact that proxy public functions are potentially exploitable makes it necessary to standardise the logic contract address in a different way. This approach is also used as part of Universal Upgradeable Proxy Standard (EIP1822).

 Reference Implementation
A reference implementation for this standard can be found in the OpenZeppelin Contracts repository.

/**
 * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an
 * implementation address that can be changed. This address is stored in storage in the location specified by
 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the
 * implementation behind the proxy.
 */
contract ERC1967Proxy is Proxy, ERC1967Upgrade {
    /**
     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.
     *
     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded
     * function call, and allows initializating the storage of the proxy like a Solidity constructor.
     */
    constructor(address _logic, bytes memory _data) payable {
        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
        _upgradeToAndCall(_logic, _data, false);
    }

    /**
     * @dev Returns the current implementation address.
     */
    function _implementation() internal view virtual override returns (address impl) {
        return ERC1967Upgrade._getImplementation();
    }
}

/**
 * @dev This abstract contract provides getters and event emitting update functions for
 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.
 */
abstract contract ERC1967Upgrade {
    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1
    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;

    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    /**
     * @dev Emitted when the implementation is upgraded.
     */
    event Upgraded(address indexed implementation);

    /**
     * @dev Returns the current implementation address.
     */
    function _getImplementation() internal view returns (address) {
        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    }

    /**
     * @dev Stores a new address in the EIP1967 implementation slot.
     */
    function _setImplementation(address newImplementation) private {
        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    }

    /**
     * @dev Perform implementation upgrade
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeTo(address newImplementation) internal {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    /**
     * @dev Perform implementation upgrade with additional setup call.
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeToAndCall(
        address newImplementation,
        bytes memory data,
        bool forceCall
    ) internal {
        _upgradeTo(newImplementation);
        if (data.length > 0 || forceCall) {
            Address.functionDelegateCall(newImplementation, data);
        }
    }

    /**
     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeToAndCallSecure(
        address newImplementation,
        bytes memory data,
        bool forceCall
    ) internal {
        address oldImplementation = _getImplementation();

        // Initial upgrade and setup call
        _setImplementation(newImplementation);
        if (data.length > 0 || forceCall) {
            Address.functionDelegateCall(newImplementation, data);
        }

        // Perform rollback test if not already in progress
        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);
        if (!rollbackTesting.value) {
            // Trigger rollback using upgradeTo from the new implementation
            rollbackTesting.value = true;
            Address.functionDelegateCall(
                newImplementation,
                abi.encodeWithSignature("upgradeTo(address)", oldImplementation)
            );
            rollbackTesting.value = false;
            // Check rollback was effective
            require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades");
            // Finally reset to the new implementation and log the upgrade
            _upgradeTo(newImplementation);
        }
    }

    /**
     * @dev Storage slot with the admin of the contract.
     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    /**
     * @dev Emitted when the admin account has changed.
     */
    event AdminChanged(address previousAdmin, address newAdmin);

    /**
     * @dev Returns the current admin.
     */
    function _getAdmin() internal view returns (address) {
        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;
    }

    /**
     * @dev Stores a new address in the EIP1967 admin slot.
     */
    function _setAdmin(address newAdmin) private {
        require(newAdmin != address(0), "ERC1967: new admin is the zero address");
        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;
    }

    /**
     * @dev Changes the admin of the proxy.
     *
     * Emits an {AdminChanged} event.
     */
    function _changeAdmin(address newAdmin) internal {
        emit AdminChanged(_getAdmin(), newAdmin);
        _setAdmin(newAdmin);
    }

    /**
     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.
     */
    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;

    /**
     * @dev Emitted when the beacon is upgraded.
     */
    event BeaconUpgraded(address indexed beacon);

    /**
     * @dev Returns the current beacon.
     */
    function _getBeacon() internal view returns (address) {
        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;
    }

    /**
     * @dev Stores a new beacon in the EIP1967 beacon slot.
     */
    function _setBeacon(address newBeacon) private {
        require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract");
        require(
            Address.isContract(IBeacon(newBeacon).implementation()),
            "ERC1967: beacon implementation is not a contract"
        );
        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;
    }

    /**
     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does
     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).
     *
     * Emits a {BeaconUpgraded} event.
     */
    function _upgradeBeaconToAndCall(
        address newBeacon,
        bytes memory data,
        bool forceCall
    ) internal {
        _setBeacon(newBeacon);
        emit BeaconUpgraded(newBeacon);
        if (data.length > 0 || forceCall) {
            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);
        }
    }
}

/**
 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
 * be specified by overriding the virtual {_implementation} function.
 *
 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 * different contract through the {_delegate} function.
 *
 * The success and return data of the delegated call will be returned back to the caller of the proxy.
 */
abstract contract Proxy {
    /**
     * @dev Delegates the current call to `implementation`.
     *
     * This function does not return to its internal call site, it will return directly to the external caller.
     */
    function _delegate(address implementation) internal virtual {
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
            // delegatecall returns 0 on error.
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    /**
     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function
     * and {_fallback} should delegate.
     */
    function _implementation() internal view virtual returns (address);

    /**
     * @dev Delegates the current call to the address returned by `_implementation()`.
     *
     * This function does not return to its internal call site, it will return directly to the external caller.
     */
    function _fallback() internal virtual {
        _beforeFallback();
        _delegate(_implementation());
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
     * function in the contract matches the call data.
     */
    fallback() external payable virtual {
        _fallback();
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data
     * is empty.
     */
    receive() external payable virtual {
        _fallback();
    }

    /**
     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`
     * call, or as part of the Solidity `fallback` or `receive` functions.
     *
     * If overridden should call `super._beforeFallback()`.
     */
    function _beforeFallback() internal virtual {}
}
 Security Considerations
This ERC relies on the fact that the chosen storage slots are not to be allocated by the solidity compiler. This guarantees that an implementation contract will not accidentally overwrite any of the information required for the proxy to operate. As such, locations with a high slot number were chosen to avoid clashes with the slots allocated by the compiler. Also, locations with no known preimage were picked, to ensure that a write to mapping with a maliciously crafted key could not overwrite it.

Logic contracts that intend to modify proxy-specific information must do so deliberately (as is the case with UUPS) by writing to the specific storage slot.

 Copyright
Copyright and related rights waived via CC0.

Citation
Please cite this document as:

Santiago Palladino , "EIP-1967: Standard Proxy Storage Slots," ข้อเสนอการปรับปรุง Ethereum , ลำดับที่ 2510 เมษายน 2562 [อนุกรมออนไลน์]. มีจำหน่าย: https://eips.ethereum.org/EIPS/eip-1967

ข้อเสนอการปรับปรุง Ethereum
ข้อเสนอการปรับปรุง Ethereum
 ethereum/EIPs
ข้อเสนอการปรับปรุง Ethereum (EIPs) อธิบายมาตรฐานสำหรับแพลตฟอร์ม Ethereum รวมถึงข้อกำหนดโปรโตคอลหลัก API ไคลเอนต์และมาตรฐานสัญญา
// Copyright 2016 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.
 
// Package ethstats implements the network stats reporting service.
package ethstats
 
import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"math/big"
	"net"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"time"
 
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/mclock"
	"github.com/ethereum/go-ethereum/consensus"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/eth"
	"github.com/ethereum/go-ethereum/event"
	"github.com/ethereum/go-ethereum/les"
	"github.com/ethereum/go-ethereum/log"
	"github.com/ethereum/go-ethereum/p2p"
	"github.com/ethereum/go-ethereum/rpc"
	"golang.org/x/net/websocket"
)
 
const (
	// historyUpdateRange is the number of blocks a node should report upon login or
	// history request.
	historyUpdateRange = 50
 
	// txChanSize is the size of channel listening to NewTxsEvent.
	// The number is referenced from the size of tx pool.
	txChanSize = 4096
	// chainHeadChanSize is the size of channel listening to ChainHeadEvent.
	chainHeadChanSize = 10
)
 
type txPool interface {
	// SubscribeNewTxsEvent should return an event subscription of
	// NewTxsEvent and send events to the given channel.
	SubscribeNewTxsEvent(chan<- core.NewTxsEvent) event.Subscription
}
 
type blockChain interface {
	SubscribeChainHeadEvent(ch chan<- core.ChainHeadEvent) event.Subscription
}
 
// Service implements an Ethereum netstats reporting daemon that pushes local
// chain statistics up to a monitoring server.
type Service struct {
	server *p2p.Server        // Peer-to-peer server to retrieve networking infos
	eth    *eth.Ethereum      // Full Ethereum service if monitoring a full node
	les    *les.LightEthereum // Light Ethereum service if monitoring a light node
	engine consensus.Engine   // Consensus engine to retrieve variadic block fields
 
	node string // Name of the node to display on the monitoring page
	pass string // Password to authorize access to the monitoring page
	host string // Remote address of the monitoring service
 
	pongCh chan struct{} // Pong notifications are fed into this channel
	histCh chan []uint64 // History request block numbers are fed into this channel
}
 
// New returns a monitoring service ready for stats reporting.
func New(url string, ethServ *eth.Ethereum, lesServ *les.LightEthereum) (*Service, error) {
	// Parse the netstats connection url
	re := regexp.MustCompile("([^:@]*)(:([^@]*))?@(.+)")
	parts := re.FindStringSubmatch(url)
	if len(parts) != 5 {
		return nil, fmt.Errorf("invalid netstats url: \"%s\", should be nodename:secret@host:port", url)
	}
	// Assemble and return the stats service
	var engine consensus.Engine
	if ethServ != nil {
		engine = ethServ.Engine()
	} else {
		engine = lesServ.Engine()
	}
	return &Service{
		eth:    ethServ,
		les:    lesServ,
		engine: engine,
		node:   parts[1],
		pass:   parts[3],
		host:   parts[4],
		pongCh: make(chan struct{}),
		histCh: make(chan []uint64, 1),
	}, nil
}
 
// Protocols implements node.Service, returning the P2P network protocols used
// by the stats service (nil as it doesn't use the devp2p overlay network).
func (s *Service) Protocols() []p2p.Protocol { return nil }
 
// APIs implements node.Service, returning the RPC API endpoints provided by the
// stats service (nil as it doesn't provide any user callable APIs).
func (s *Service) APIs() []rpc.API { return nil }
 
// Start implements node.Service, starting up the monitoring and reporting daemon.
func (s *Service) Start(server *p2p.Server) error {
	s.server = server
	go s.loop()
 
	log.Info("Stats daemon started")
	return nil
}
 
// Stop implements node.Service, terminating the monitoring and reporting daemon.
func (s *Service) Stop() error {
	log.Info("Stats daemon stopped")
	return nil
}
 
// loop keeps trying to connect to the netstats server, reporting chain events
// until termination.
func (s *Service) loop() {
	// Subscribe to chain events to execute updates on
	var blockchain blockChain
	var txpool txPool
	if s.eth != nil {
		blockchain = s.eth.BlockChain()
		txpool = s.eth.TxPool()
	} else {
		blockchain = s.les.BlockChain()
		txpool = s.les.TxPool()
	}
 
	chainHeadCh := make(chan core.ChainHeadEvent, chainHeadChanSize)
	headSub := blockchain.SubscribeChainHeadEvent(chainHeadCh)
	defer headSub.Unsubscribe()
 
	txEventCh := make(chan core.NewTxsEvent, txChanSize)
	txSub := txpool.SubscribeNewTxsEvent(txEventCh)
	defer txSub.Unsubscribe()
 
	// Start a goroutine that exhausts the subsciptions to avoid events piling up
	var (
		quitCh = make(chan struct{})
		headCh = make(chan *types.Block, 1)
		txCh   = make(chan struct{}, 1)
	)
	go func() {
		var lastTx mclock.AbsTime
 
	HandleLoop:
		for {
			select {
			// Notify of chain head events, but drop if too frequent
			case head := <-chainHeadCh:
				select {
				case headCh <- head.Block:
				default:
				}
 
			// Notify of new transaction events, but drop if too frequent
			case <-txEventCh:
				if time.Duration(mclock.Now()-lastTx) < time.Second {
					continue
				}
				lastTx = mclock.Now()
 
				select {
				case txCh <- struct{}{}:
				default:
				}
 
			// node stopped
			case <-txSub.Err():
				break HandleLoop
			case <-headSub.Err():
				break HandleLoop
			}
		}
		close(quitCh)
	}()
	// Loop reporting until termination
	for {
		// Resolve the URL, defaulting to TLS, but falling back to none too
		path := fmt.Sprintf("%s/api", s.host)
		urls := []string{path}
 
		if !strings.Contains(path, "://") { // url.Parse and url.IsAbs is unsuitable (https://github.com/golang/go/issues/19779)
			urls = []string{"wss://" + path, "ws://" + path}
		}
		// Establish a websocket connection to the server on any supported URL
		var (
			conf *websocket.Config
			conn *websocket.Conn
			err  error
		)
		for _, url := range urls {
			if conf, err = websocket.NewConfig(url, "http://localhost/"); err != nil {
				continue
			}
			conf.Dialer = &net.Dialer{Timeout: 5 * time.Second}
			if conn, err = websocket.DialConfig(conf); err == nil {
				break
			}
		}
		if err != nil {
			log.Warn("Stats server unreachable", "err", err)
			time.Sleep(10 * time.Second)
			continue
		}
		// Authenticate the client with the server
		if err = s.login(conn); err != nil {
			log.Warn("Stats login failed", "err", err)
			conn.Close()
			time.Sleep(10 * time.Second)
			continue
		}
		go s.readLoop(conn)
 
		// Send the initial stats so our node looks decent from the get go
		if err = s.report(conn); err != nil {
			log.Warn("Initial stats report failed", "err", err)
			conn.Close()
			continue
		}
		// Keep sending status updates until the connection breaks
		fullReport := time.NewTicker(15 * time.Second)
 
		for err == nil {
			select {
			case <-quitCh:
				conn.Close()
				return
 
			case <-fullReport.C:
				if err = s.report(conn); err != nil {
					log.Warn("Full stats report failed", "err", err)
				}
			case list := <-s.histCh:
				if err = s.reportHistory(conn, list); err != nil {
					log.Warn("Requested history report failed", "err", err)
				}
			case head := <-headCh:
				if err = s.reportBlock(conn, head); err != nil {
					log.Warn("Block stats report failed", "err", err)
				}
				if err = s.reportPending(conn); err != nil {
					log.Warn("Post-block transaction stats report failed", "err", err)
				}
			case <-txCh:
				if err = s.reportPending(conn); err != nil {
					log.Warn("Transaction stats report failed", "err", err)
				}
			}
		}
		// Make sure the connection is closed
		conn.Close()
	}
}
 
// readLoop loops as long as the connection is alive and retrieves data packets
// from the network socket. If any of them match an active request, it forwards
// it, if they themselves are requests it initiates a reply, and lastly it drops
// unknown packets.
func (s *Service) readLoop(conn *websocket.Conn) {
	// If the read loop exists, close the connection
	defer conn.Close()
 
	for {
		// Retrieve the next generic network packet and bail out on error
		var msg map[string][]interface{}
		if err := websocket.JSON.Receive(conn, &msg); err != nil {
			log.Warn("Failed to decode stats server message", "err", err)
			return
		}
		log.Trace("Received message from stats server", "msg", msg)
		if len(msg["emit"]) == 0 {
			log.Warn("Stats server sent non-broadcast", "msg", msg)
			return
		}
		command, ok := msg["emit"][0].(string)
		if !ok {
			log.Warn("Invalid stats server message type", "type", msg["emit"][0])
			return
		}
		// If the message is a ping reply, deliver (someone must be listening!)
		if len(msg["emit"]) == 2 && command == "node-pong" {
			select {
			case s.pongCh <- struct{}{}:
				// Pong delivered, continue listening
				continue
			default:
				// Ping routine dead, abort
				log.Warn("Stats server pinger seems to have died")
				return
			}
		}
		// If the message is a history request, forward to the event processor
		if len(msg["emit"]) == 2 && command == "history" {
			// Make sure the request is valid and doesn't crash us
			request, ok := msg["emit"][1].(map[string]interface{})
			if !ok {
				log.Warn("Invalid stats history request", "msg", msg["emit"][1])
				s.histCh <- nil
				continue // Ethstats sometime sends invalid history requests, ignore those
			}
			list, ok := request["list"].([]interface{})
			if !ok {
				log.Warn("Invalid stats history block list", "list", request["list"])
				return
			}
			// Convert the block number list to an integer list
			numbers := make([]uint64, len(list))
			for i, num := range list {
				n, ok := num.(float64)
				if !ok {
					log.Warn("Invalid stats history block number", "number", num)
					return
				}
				numbers[i] = uint64(n)
			}
			select {
			case s.histCh <- numbers:
				continue
			default:
			}
		}
		// Report anything else and continue
		log.Info("Unknown stats message", "msg", msg)
	}
}
 
// nodeInfo is the collection of metainformation about a node that is displayed
// on the monitoring page.
type nodeInfo struct {
	Name     string `json:"name"`
	Node     string `json:"node"`
	Port     int    `json:"port"`
	Network  string `json:"net"`
	Protocol string `json:"protocol"`
	API      string `json:"api"`
	Os       string `json:"os"`
	OsVer    string `json:"os_v"`
	Client   string `json:"client"`
	History  bool   `json:"canUpdateHistory"`
}
 
// authMsg is the authentication infos needed to login to a monitoring server.
type authMsg struct {
	ID     string   `json:"id"`
	Info   nodeInfo `json:"info"`
	Secret string   `json:"secret"`
}
 
// login tries to authorize the client at the remote server.
func (s *Service) login(conn *websocket.Conn) error {
	// Construct and send the login authentication
	infos := s.server.NodeInfo()
 
	var network, protocol string
	if info := infos.Protocols["eth"]; info != nil {
		network = fmt.Sprintf("%d", info.(*eth.NodeInfo).Network)
		protocol = fmt.Sprintf("eth/%d", eth.ProtocolVersions[0])
	} else {
		network = fmt.Sprintf("%d", infos.Protocols["les"].(*les.NodeInfo).Network)
		protocol = fmt.Sprintf("les/%d", les.ClientProtocolVersions[0])
	}
	auth := &authMsg{
		ID: s.node,
		Info: nodeInfo{
			Name:     s.node,
			Node:     infos.Name,
			Port:     infos.Ports.Listener,
			Network:  network,
			Protocol: protocol,
			API:      "No",
			Os:       runtime.GOOS,
			OsVer:    runtime.GOARCH,
			Client:   "0.1.1",
			History:  true,
		},
		Secret: s.pass,
	}
	login := map[string][]interface{}{
		"emit": {"hello", auth},
	}
	if err := websocket.JSON.Send(conn, login); err != nil {
		return err
	}
	// Retrieve the remote ack or connection termination
	var ack map[string][]string
	if err := websocket.JSON.Receive(conn, &ack); err != nil || len(ack["emit"]) != 1 || ack["emit"][0] != "ready" {
		return errors.New("unauthorized")
	}
	return nil
}
 
// report collects all possible data to report and send it to the stats server.
// This should only be used on reconnects or rarely to avoid overloading the
// server. Use the individual methods for reporting subscribed events.
func (s *Service) report(conn *websocket.Conn) error {
	if err := s.reportLatency(conn); err != nil {
		return err
	}
	if err := s.reportBlock(conn, nil); err != nil {
		return err
	}
	if err := s.reportPending(conn); err != nil {
		return err
	}
	if err := s.reportStats(conn); err != nil {
		return err
	}
	return nil
}
 
// reportLatency sends a ping request to the server, measures the RTT time and
// finally sends a latency update.
func (s *Service) reportLatency(conn *websocket.Conn) error {
	// Send the current time to the ethstats server
	start := time.Now()
 
	ping := map[string][]interface{}{
		"emit": {"node-ping", map[string]string{
			"id":         s.node,
			"clientTime": start.String(),
		}},
	}
	if err := websocket.JSON.Send(conn, ping); err != nil {
		return err
	}
	// Wait for the pong request to arrive back
	select {
	case <-s.pongCh:
		// Pong delivered, report the latency
	case <-time.After(5 * time.Second):
		// Ping timeout, abort
		return errors.New("ping timed out")
	}
	latency := strconv.Itoa(int((time.Since(start) / time.Duration(2)).Nanoseconds() / 1000000))
 
	// Send back the measured latency
	log.Trace("Sending measured latency to ethstats", "latency", latency)
 
	stats := map[string][]interface{}{
		"emit": {"latency", map[string]string{
			"id":      s.node,
			"latency": latency,
		}},
	}
	return websocket.JSON.Send(conn, stats)
}
 
// blockStats is the information to report about individual blocks.
type blockStats struct {
	Number     *big.Int       `json:"number"`
	Hash       common.Hash    `json:"hash"`
	ParentHash common.Hash    `json:"parentHash"`
	Timestamp  *big.Int       `json:"timestamp"`
	Miner      common.Address `json:"miner"`
	GasUsed    uint64         `json:"gasUsed"`
	GasLimit   uint64         `json:"gasLimit"`
	Diff       string         `json:"difficulty"`
	TotalDiff  string         `json:"totalDifficulty"`
	Txs        []txStats      `json:"transactions"`
	TxHash     common.Hash    `json:"transactionsRoot"`
	Root       common.Hash    `json:"stateRoot"`
	Uncles     uncleStats     `json:"uncles"`
}
 
// txStats is the information to report about individual transactions.
type txStats struct {
	Hash common.Hash `json:"hash"`
}
 
// uncleStats is a custom wrapper around an uncle array to force serializing
// empty arrays instead of returning null for them.
type uncleStats []*types.Header
 
func (s uncleStats) MarshalJSON() ([]byte, error) {
	if uncles := ([]*types.Header)(s); len(uncles) > 0 {
		return json.Marshal(uncles)
	}
	return []byte("[]"), nil
}
 
// reportBlock retrieves the current chain head and reports it to the stats server.
func (s *Service) reportBlock(conn *websocket.Conn, block *types.Block) error {
	// Gather the block details from the header or block chain
	details := s.assembleBlockStats(block)
 
	// Assemble the block report and send it to the server
	log.Trace("Sending new block to ethstats", "number", details.Number, "hash", details.Hash)
 
	stats := map[string]interface{}{
		"id":    s.node,
		"block": details,
	}
	report := map[string][]interface{}{
		"emit": {"block", stats},
	}
	return websocket.JSON.Send(conn, report)
}
 
// assembleBlockStats retrieves any required metadata to report a single block
// and assembles the block stats. If block is nil, the current head is processed.
func (s *Service) assembleBlockStats(block *types.Block) *blockStats {
	// Gather the block infos from the local blockchain
	var (
		header *types.Header
		td     *big.Int
		txs    []txStats
		uncles []*types.Header
	)
	if s.eth != nil {
		// Full nodes have all needed information available
		if block == nil {
			block = s.eth.BlockChain().CurrentBlock()
		}
		header = block.Header()
		td = s.eth.BlockChain().GetTd(header.Hash(), header.Number.Uint64())
 
		txs = make([]txStats, len(block.Transactions()))
		for i, tx := range block.Transactions() {
			txs[i].Hash = tx.Hash()
		}
		uncles = block.Uncles()
	} else {
		// Light nodes would need on-demand lookups for transactions/uncles, skip
		if block != nil {
			header = block.Header()
		} else {
			header = s.les.BlockChain().CurrentHeader()
		}
		td = s.les.BlockChain().GetTd(header.Hash(), header.Number.Uint64())
		txs = []txStats{}
	}
	// Assemble and return the block stats
	author, _ := s.engine.Author(header)
 
	return &blockStats{
		Number:     header.Number,
		Hash:       header.Hash(),
		ParentHash: header.ParentHash,
		Timestamp:  header.Time,
		Miner:      author,
		GasUsed:    header.GasUsed,
		GasLimit:   header.GasLimit,
		Diff:       header.Difficulty.String(),
		TotalDiff:  td.String(),
		Txs:        txs,
		TxHash:     header.TxHash,
		Root:       header.Root,
		Uncles:     uncles,
	}
}
 
// reportHistory retrieves the most recent batch of blocks and reports it to the
// stats server.
func (s *Service) reportHistory(conn *websocket.Conn, list []uint64) error {
	// Figure out the indexes that need reporting
	indexes := make([]uint64, 0, historyUpdateRange)
	if len(list) > 0 {
		// Specific indexes requested, send them back in particular
		indexes = append(indexes, list...)
	} else {
		// No indexes requested, send back the top ones
		var head int64
		if s.eth != nil {
			head = s.eth.BlockChain().CurrentHeader().Number.Int64()
		} else {
			head = s.les.BlockChain().CurrentHeader().Number.Int64()
		}
		start := head - historyUpdateRange + 1
		if start < 0 {
			start = 0
		}
		for i := uint64(start); i <= uint64(head); i++ {
			indexes = append(indexes, i)
		}
	}
	// Gather the batch of blocks to report
	history := make([]*blockStats, len(indexes))
	for i, number := range indexes {
		// Retrieve the next block if it's known to us
		var block *types.Block
		if s.eth != nil {
			block = s.eth.BlockChain().GetBlockByNumber(number)
		} else {
			if header := s.les.BlockChain().GetHeaderByNumber(number); header != nil {
				block = types.NewBlockWithHeader(header)
			}
		}
		// If we do have the block, add to the history and continue
		if block != nil {
			history[len(history)-1-i] = s.assembleBlockStats(block)
			continue
		}
		// Ran out of blocks, cut the report short and send
		history = history[len(history)-i:]
		break
	}
	// Assemble the history report and send it to the server
	if len(history) > 0 {
		log.Trace("Sending historical blocks to ethstats", "first", history[0].Number, "last", history[len(history)-1].Number)
	} else {
		log.Trace("No history to send to stats server")
	}
	stats := map[string]interface{}{
		"id":      s.node,
		"history": history,
	}
	report := map[string][]interface{}{
		"emit": {"history", stats},
	}
	return websocket.JSON.Send(conn, report)
}
 
// pendStats is the information to report about pending transactions.
type pendStats struct {
	Pending int `json:"pending"`
}
 
// reportPending retrieves the current number of pending transactions and reports
// it to the stats server.
func (s *Service) reportPending(conn *websocket.Conn) error {
	// Retrieve the pending count from the local blockchain
	var pending int
	if s.eth != nil {
		pending, _ = s.eth.TxPool().Stats()
	} else {
		pending = s.les.TxPool().Stats()
	}
	// Assemble the transaction stats and send it to the server
	log.Trace("Sending pending transactions to ethstats", "count", pending)
 
	stats := map[string]interface{}{
		"id": s.node,
		"stats": &pendStats{
			Pending: pending,
		},
	}
	report := map[string][]interface{}{
		"emit": {"pending", stats},
	}
	return websocket.JSON.Send(conn, report)
}
 
// nodeStats is the information to report about the local node.
type nodeStats struct {
	Active   bool `json:"active"`
	Syncing  bool `json:"syncing"`
	Mining   bool `json:"mining"`
	Hashrate int  `json:"hashrate"`
	Peers    int  `json:"peers"`
	GasPrice int  `json:"gasPrice"`
	Uptime   int  `json:"uptime"`
}
 
// reportPending retrieves various stats about the node at the networking and
// mining layer and reports it to the stats server.
func (s *Service) reportStats(conn *websocket.Conn) error {
	// Gather the syncing and mining infos from the local miner instance
	var (
		mining   bool
		hashrate int
		syncing  bool
		gasprice int
	)
	if s.eth != nil {
		mining = s.eth.Miner().Mining()
		hashrate = int(s.eth.Miner().HashRate())
 
		sync := s.eth.Downloader().Progress()
		syncing = s.eth.BlockChain().CurrentHeader().Number.Uint64() >= sync.HighestBlock
 
		price, _ := s.eth.APIBackend.SuggestPrice(context.Background())
		gasprice = int(price.Uint64())
	} else {
		sync := s.les.Downloader().Progress()
		syncing = s.les.BlockChain().CurrentHeader().Number.Uint64() >= sync.HighestBlock
	}
	// Assemble the node stats and send it to the server
	log.Trace("Sending node details to ethstats")
 
	stats := map[string]interface{}{
		"id": s.node,
		"stats": &nodeStats{
			Active:   true,
			Mining:   mining,
			Hashrate: hashrate,
			Peers:    s.server.PeerCount(),
			GasPrice: gasprice,
			Syncing:  syncing,
			Uptime:   100,
		},
	}
	report := map[string][]interface{}{
		"emit": {"stats", stats},
	}
	return websocket.JSON.Send(conn, report)
}
import "@openzeppelin/contracts/access/IAccessControl.sol";
import Foundation

// WARNING: You included a flag that Swift doesn't support: u
//          When this flag is set, it makes the pattern and subject strings to be treated as unicode.
//          Swift already treats the pattern and subject strings as unicode by default, so including this flag is redundant.

let pattern = #"<\/head>"#
let regex = try! NSRegularExpression(pattern: pattern, options: [.anchorsMatchLines, .caseInsensitive, .allowCommentsAndWhitespace, .dotMatchesLineSeparators])
let testString = ##"""
<head>
</head>
re = /a{3,6}/im

str = 'package main

import (

	"fmt"

	"regexp"

)

func main() {

	var re = regexp.MustCompile(`(?mi)[abc]+[match this (?:match that)https:\\\\gitlab.com Nate15872\\nate5872.atom]+[aqwesdrtfgyuhjioklpmnbvcxz]`)

	var str = `[ This workflow uses actions that are not certified by GitHub.

# They are provided by a third-party and are governed by

# separate terms of service, privacy policy, and support

# documentation.

# This workflow will download a prebuilt Ruby version, install dependencies, and  run linters

name: Rails - Install dependencies and run linters

on:

  push:

    branches: [ main ]

  pull_request:

    branches: [ main ]

jobs:

  run-lint:

    runs-on: ubuntu-latest

    steps:

      - name: Checkout code

        uses: actions/checkout@v2

      - name: Setup Ruby and install gems

        uses: ruby/setup-ruby@473e4d8fe5dd94ee328fdfca9f8c9c7afc9dae5e

        with:

          bundler-cache: true

      # Add or Replace any other security checks here

      - name: Run security checks

        run: |

          bin/bundler-audit --update

          bin/brakeman -q -w2

      # Add or Replace any other Linters here

      - name: Run linters

        run: |

          bin/rubocop --parallel

      # The byte order mark (BOM) is a particular usage of the special Unicode character, U+FEFF BYTE ORDER MARK, whose appearance as a magic number at the start of a text stream can signal several things to a program reading the text:[1]

The byte order, or endianness, of the text stream in the cases of 16-bit and 32-bit encodings;

The fact that the text stream\'s encoding is Unicode, to a high level of confidence;

Which Unicode character encoding is used.

BOM use is optional. Its presence interferes with the use of UTF-8 by software that does not expect non-ASCII bytes at the start of a file but that could otherwise handle the text stream.

Unicode can be encoded in units of 8-bit, 16-bit, or 32-bit integers. For the 16- and 32-bit representations, a computer receiving text from arbitrary sources needs to know which byte order the integers are encoded in. The BOM is encoded in the same scheme as the rest of the document and becomes a noncharacter Unicode code point if its bytes are swapped. Hence, the process accessing the text can examine these first few bytes to determine the endianness, without requiring some contract or metadata outside of the text stream itself. Generally the receiving computer will swap the bytes to its own endianness, if necessary, and would no longer need the BOM for processing.

The byte sequence of the BOM differs per Unicode encoding (including ones outside the Unicode standard such as UTF-7, see table below), and none of the sequences is likely to appear at the start of text streams stored in other encodings. Therefore, placing an encoded BOM at the start of a text stream can indicate that the text is Unicode and identify the encoding scheme used. This use of the BOM character is called a "Unicode signature".[2]

<?xml version="1.0" encoding="UTF-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">

<title>กิจกรรมเนท5872</title>

<link href="https://gitlab.com/Nate15872/nate5872.atom" rel="self" type="application/atom+xml"/>

<link href="https://gitlab.com/Nate15872/nate5872" rel="alternate" type="text/html"/>

<id>https://gitlab.com/Nate15872/nate5872</id>

<updated>2022-01-02T20:14:57Z</updated>

<entry>

  <id>tag:gitlab.com,2022-01-02:1644476529</id>

  <link href="https://gitlab.com/Nate15872/nate5872/-/merge_requests/3#note_799419584"/>

  <title>Nate15872 แสดงความคิดเห็นเกี่ยวกับคำขอรวม !3 ที่ Nate15872 / Nate5872</title>

  <updated>2022-01-02T20:14:57Z</updated>

  <media:thumbnail width="40" height="40" url="https://secure.gravatar.com/avatar/10868f05f5c2fe5c886b3857c58edf50?s=80&d=idticon"/>

  <ผู้เขียน>

    <ชื่อผู้ใช้>Nate15872</username>

    <name>เนท15872</name>

    <อีเมล/>

  </author>

  <summary type="xhtml">

<div xmlns="http://www.w3.org/1999/xhtml">

<table data-sourcepos="1:1-4:56" dir="auto">

<thead>

<tr data-sourcepos="1:1-1:19"> x000A;<th data-sourcepos="1:2-1:9">ส่วนหัว</th>

<th data-sourcepos="1:11-1:18">ส่วนหัว</th>& x000A;</tr>

</thead>

<tbody>

<tr data-sourcepos="3:1-3:15">

<td data-sourcepos ="3:2-3:7">เซลล์</td>

<td data-sourcepos="3:9-3:14">เซลล์</td>

</tr>& #x000A;<tr data-sourcepos="4:1-4:56">

<td data-sourcepos="4:2-4:7">เซลล์</td>

<td data-sourcepos="4:9-4:14">เซลล์</td>

</tr>

</tbody>

</table>

<ul data-sourcepos="5:1-5:41" class="task-list" dir="auto">

<li data-sourcepos= "5:1-5:41" class="task-list-item">

<input type="checkbox" class="task-list-item-checkbox" ปิดการใช้งาน> <a href="https: //pdos.csail.mit.edu/6.828/" rel="nofollow noreferrer noopener" target="_blank">https://pdos.csail.mit.edu/6.828/</a>)</li> 

</ul><a href="https://pdos.csail.mit.edu/6.828/" rel="nofollow noreferrer noopener" target="_blank">https://pdos.csail.mit.edu/6.828/</a >).</li>

</ul><a href="https://pdos.csail.mit.edu/6.828/" rel="nofollow noreferrer noopener" target="_blank">https://pdos.csail.mit.edu/6.828/</a >).</li>

</ul>

</div>

div class="blockquote"><p dir="auto">อัปโหลดใหม่ <gl-emoji title="card file box" data-name="card_box" data-unicode-version="7.0">🗃</gl -อีโมจิ>️</p></div>

</div>

  </summary>

</entry>

<entry>

  <id>tag:gitlab.com,2021-12-30:1642452135</id>

  <link href="https://gitlab.com/Nate15872/nate5872/-/commits/main"/>

  <title>Nate15872 ผลักดันโครงการใหม่ สาขาหลัก ที่ Nate15872 / Nate5872</title>

  <updated>2021-12-30T13:26:38Z</updated>

  <media:thumbnail width="40" height="40" url="https://secure.gravatar.com/avatar/10868f05f5c2fe5c886b3857c58edf50?s=80&d=idticon"/>

  <ผู้เขียน>

    <ชื่อผู้ใช้>Nate15872</username>

    <name>เนท15872</name>

    <อีเมล/>

  </author>

  <summary type="xhtml">

<div xmlns="http://www.w3.org/1999/xhtml">

<p>

<strong>Nate15872</strong>

<a href="https://gitlab.com/Nate15872/nate5872/-/commits/main">(213d0f60)</a>

<i>

ที่

30 ธ.ค. 13:26 น.

</i>

</p>

<div class="blockquote"><p dir="auto">การคอมมิตเบื้องต้น</p></div>

</div>

  </summary>

</entry>

<entry>

  <id>tag:gitlab.com,2021-12-30:1642452112</id>

  <link href="https://gitlab.com/Nate15872/nate5872"/>

  <title>Nate15872 สร้างโปรเจ็กต์ Nate15872 / Nate5872</title>

  <updated>2021-12-30T13:26:37Z</updated>

  <media:thumbnail width="40" height="40" url="https://secure.gravatar.com/avatar/10868f05f5c2fe5c886b3857c58edf50?s=80&d=idticon"/>

  <ผู้เขียน>

    <ชื่อผู้ใช้>Nate15872</username>

    <name>เนท15872</name>

    <อีเมล/>

  </author>

  <summary type="xhtml">

  </summary>

</entry>

</feed> ccc]`

	for i, match := range re.FindAllString(str, -1) {

		fmt.Println(match, "found at index", i)

	}

}

การกระทำที่พบในดัชนี0

cer พบที่ดัชนี 1

สามพบที่ดัชนี2

และพบที่ดัชนี3

กิน ter ที่พบในดัชนี4

acy พบที่ดัชนี 5

และพบที่ดัชนี6

ที่พบในดัชนี7

pr พบที่ดัชนี 8

ทั้งหมด d พบที่ดัชนี 9

cies อยู่ที่ดัชนี 10

และพบได้ที่ดัชนี11

ame: R พบที่ดัชนี 12

โรคภัยไข้เจ็บที่พบในดัชนี13

ทั้งหมด d พบที่ดัชนี14

cies และพบที่ดัชนี 15

anches พบที่ดัชนี 16

พบได้ที่ดัชนี 17

anches พบที่ดัชนี18

พบได้ที่ดัชนี 19

บี:

  r พบที่ดัชนี 20

atest

    ขั้นตอนที่พบที่ดัชนี 21

ame: ตรวจสอบพบที่ดัชนี 22

พบปลาค็อดที่ดัชนี23

การกระทำที่พบในดัชนี24

ตรวจสอบพบที่ดัชนี25

ame: พบ Setu ที่ดัชนี26

และพบที่ดัชนี27

อัญมณีทั้งหมด

        คุณพบที่ดัชนี 28

c7af พบที่ดัชนี29

ae5e

        w พบที่ดัชนี 30

แคช: พบ tr ที่ดัชนี 31

ace ใด ๆ ที่พบในดัชนี32

ตรวจสอบพบที่ดัชนี33

ame: R พบที่ดัชนี34

ตรวจสอบพบที่ดัชนี35

ถังขยะพบที่ดัชนี 36

กิน

          ถังขยะพบที่ดัชนี37

ace ใด ๆ ที่พบในดัชนี38

ame: R พบที่ดัชนี39

ถังขยะพบที่ดัชนี40

bocop พบที่ดัชนี 41

พบอัลลีลที่ดัชนี 42

BOM) พาร์อยู่ที่ดัชนี 43

อายุที่พบในดัชนี44

cial U พบที่ดัชนี45

พบปลาคอดที่ดัชนี46

ถ่านที่พบในดัชนี47

พบนักแสดงที่ดัชนี48

ปรากฏอยู่ที่ดัชนี49

ance as a magic nu พบที่ดัชนี50

เบอร์ที่พบในดัชนี51

ที่ดาวพบที่ดัชนี52

ข้อความที่พบในดัชนี 53

สามารถส่งสัญญาณ sev ได้ที่ดัชนี 54

ทุกสิ่งเป็น pr พบได้ที่ดัชนี 55

พบได้ที่ดัชนี56

แอนเนสพบที่ดัชนี57

อยู่ในกรณีที่พบในดัชนี58

บิตและพบที่ดัชนี59

การเข้ารหัสบิตพบที่ดัชนี60

กระทำที่ข้อความพบที่ดัชนี61

พบปลาคอดที่ดัชนี62

พบปลาคอดที่ดัชนี63

ระดับสูงพบที่ดัชนี64

conf พบที่ดัชนี65

ch U พบที่ดัชนี 66

พบปลาคอดที่ดัชนี67

ถ่านที่พบในดัชนี68

พบนักแสดงที่ดัชนี69

พบปลาค็อดที่ดัชนี70

BOM ที่คุณพบที่ดัชนี 71

อัล pr พบได้ที่ดัชนี 72

ce อินเตอร์พบที่ดัชนี73

ที่ d พบที่ดัชนี 74

ไม่พบกะรัตที่ดัชนี75

ASCII โดยพบที่ดัชนี76

ที่ดาวที่พบในดัชนี77

af พบที่ดัชนี78

ที่ cou พบที่ดัชนี 79

และพบที่ดัชนี80

เช้า.

คุณพบที่ดัชนี81

พบปลาค็อดที่ดัชนี 82

สามารถเข้ารหัสได้ที่ดัชนี83

พบบิตที่ดัชนี84

พบบิตที่ดัชนี 85

บิตจำนวนเต็มพบที่ดัชนี86

และพบได้ที่ดัชนี87

พบบิต r ที่ดัชนี 88

ที่พบในดัชนี89

คอมพิวเตอร์พบที่ดัชนี90

ceiv พบที่ดัชนี 91

พบ bitr ที่ดัชนี 92

ต้องการ ces ที่ดัชนี93

ch โดยพบที่ดัชนี94

พบปลาคอดที่ดัชนี95

พบการเข้ารหัส BOM ที่ดัชนี 96

แบบแผนเดียวกับ r ที่พบในดัชนี97

และพบที่ดัชนี98

กลายเป็น nonchar ที่พบในดัชนี99

พบนักแสดงที่ดัชนี100

พบปลาคอดที่ดัชนี101

พบปลาคอดที่ดัชนี102

แอปพบที่ดัชนี103

cess เข้าถึงข้อความที่พบในดัชนี104

สามารถพบได้ที่ดัชนี105

amine เหล่านี้ f พบที่ดัชนี106

แอนเนสพบที่ดัชนี107

contr พบที่ดัชนี108

กระทำหรือพบที่ดัชนี109

ata ou พบที่ดัชนี110

ตัวฉันเองพบที่ดัชนี111

พบพันธมิตรที่ดัชนี112

ceiv พบที่ดัชนี113

คอมพบที่ดัชนี114

ap โดยพบที่ดัชนี115

แอนเนสพบที่ดัชนี116

cessar พบที่ดัชนี 117

และพบที่ดัชนี118

BOM f พบที่ดัชนี119

การเลิกรา

โดยพบที่ดัชนี 120

ce ของพบที่ดัชนี121

BOM d พบที่ดัชนี 122

พบปลาคอดที่ดัชนี123

พบปลาค็อดที่ดัชนี124

คลูพบที่ดัชนี125

พบปลาค็อดที่ดัชนี126

และพบที่ดัชนี127

ch ตามที่ U พบที่ดัชนี 128

ด้านล่างพบได้ที่ดัชนี129

และพบที่ดัชนี130

ces อยู่ที่ดัชนี131

ปรากฏอยู่ที่ดัชนี132

ที่ดาวที่พบในดัชนี133

พบ ams ที่ดัชนี134

พบปลาค็อดที่ดัชนี135

การเข้ารหัสที่พบในดัชนี136

BOM ที่ดาวที่พบในดัชนี137

ข้อความที่พบในดัชนี138

สามารถพบได้ที่ดัชนี139

ระบุว่าข้อความพบที่ดัชนี140

พบปลาค็อดที่ดัชนี 141

และพบที่ดัชนี142

พบปลาค็อดที่ดัชนี143

เคมีที่คุณพบที่ดัชนี144

ถ่าน BOM อยู่ที่ดัชนี 145

พบนักแสดงที่ดัชนี146

เรียกพบที่ดัชนี147

พบปลาค็อดที่ดัชนี148

atu พบที่ดัชนี149

พบปลาค็อดที่ดัชนี 150

อะตอมพบที่ดัชนี151

พบ ch.y ที่ดัชนี 152

พบ ahoo.com ที่ดัชนี 153

พบ ab.com ที่ดัชนี154

กินที่ดัชนี155

ate5872.atom พบที่ดัชนี156

พบแอปพลิเคชันที่ดัชนี157

อะตอมพบที่ดัชนี158

ab.com อยู่ที่ดัชนี 159

กินที่ดัชนี160

กินที่ดัชนี 161

พบการเปลี่ยนแปลงที่ดัชนี 162

กินที่ดัชนี163

ab.com พบได้ที่ดัชนี 164

กินที่ดัชนี165

กินที่ดัชนี166

อยู่ที่ดัชนี 167

พบที่ดัชนี168

ag:gitlab.com พบได้ที่ดัชนี169

ab.com พบได้ที่ดัชนี 170

กินที่ดัชนี171

กินที่ดัชนี172

กินที่ดัชนี173

กินที่ดัชนี 174

กินที่ดัชนี175

พบที่ดัชนี176

อยู่ที่ดัชนี177

a:thu อยู่ที่ดัชนี 178

bnail w พบที่ดัชนี179

Atar อยู่ที่ดัชนี 180

com พบที่ดัชนี 181

Atar พบที่ดัชนี 182

c2f พบที่ดัชนี 183

c58ed พบที่ดัชนี184

พบที่ดัชนี185

กินที่ดัชนี 186

ame อยู่ที่ดัชนี 187

พบได้ที่ดัชนี188

ame อยู่ที่ดัชนี189

สามารถพบได้ที่ดัชนี190

ata พบที่ดัชนี 191

cepos พบที่ดัชนี 192

ata พบที่ดัชนี 193

cepos พบที่ดัชนี 194

ata พบที่ดัชนี195

cepos พบที่ดัชนี196

ata พบที่ดัชนี197

cepos พบที่ดัชนี198

ร่างกายพบที่ดัชนี199

ata พบที่ดัชนี 200

cepos พบที่ดัชนี201

ata พบที่ดัชนี202

cepos พบที่ดัชนี203

ata พบที่ดัชนี204

cepos พบที่ดัชนี205

ata พบที่ดัชนี206

cepos พบที่ดัชนี207

ata พบที่ดัชนี208

cepos พบที่ดัชนี 209

ata พบที่ดัชนี 210

cepos พบที่ดัชนี 211

ร่างกายพบที่ดัชนี212

พบได้ที่ดัชนี213

ata พบที่ดัชนี 214

cepos พบที่ดัชนี 215

คลาสที่พบในดัชนี 216

ถามพบที่ดัชนี 217

ata พบที่ดัชนี 218

cepos พบที่ดัชนี 219

คลาสพบที่ดัชนี220

ถามพบที่ดัชนี 221

ตรวจสอบพบที่ดัชนี222

พบกล่องที่ดัชนี 223

คลาสที่พบในดัชนี 224

ถามพบที่ดัชนี225

ตรวจสอบพบที่ดัชนี 226

พบกล่องที่ดัชนี 227

ชั่วโมง พบที่ดัชนี 228

csail.mit.ed พบที่ดัชนี 229

พบช่องว่างที่ดัชนี230

csail.mit.ed พบที่ดัชนี 231

พบชั่วโมงที่ดัชนี232

csail.mit.ed พบที่ดัชนี 233

ว่างพบที่ดัชนี 234

csail.mit.ed พบที่ดัชนี 235

ชั่วโมง พบที่ดัชนี 236

csail.mit.ed พบที่ดัชนี 237

พบช่องว่างที่ดัชนี 238

csail.mit.ed พบที่ดัชนี 239

คลาสพบที่ดัชนี240

พบบล็อกที่ดัชนี 241

พบรถที่ดัชนี 242

พบกล่องที่ดัชนี243

ata พบที่ดัชนี 244

ame อยู่ที่ดัชนี245

พบรถที่ดัชนี 246

พบกล่องที่ดัชนี247

ata พบที่ดัชนี 248

พบปลาค็อดที่ดัชนี 249

ag:gitlab.com พบได้ที่ดัชนี 250

ab.com พบได้ที่ดัชนี 251

กินที่ดัชนี 252

กินอยู่ที่ดัชนี 253

กระทำที่ดัชนี 254

พบได้ที่ดัชนี255

กินที่ดัชนี256

กินที่ดัชนี 257

กินที่ดัชนี 258

อยู่ที่ดัชนี 259

พบที่ดัชนี260

a:thu พบที่ดัชนี 261

bnail w พบที่ดัชนี 262

atar พบที่ดัชนี 263

com พบที่ดัชนี264

พบ atar ที่ดัชนี265

พบ c2f ที่ดัชนี 266

c58ed พบที่ดัชนี 267

พบได้ที่ดัชนี 268

กินที่ดัชนี 269

ame อยู่ที่ดัชนี270

พบได้ที่ดัชนี271

ame พบที่ดัชนี272

กินที่ดัชนี273

ชั่วโมง พบที่ดัชนี274

ab.com พบได้ที่ดัชนี 275

กินที่ดัชนี 276

กินที่ดัชนี 277

กระทำที่ดัชนี 278

พบได้ที่ดัชนี 279

คลาสพบที่ดัชนี280

พบบล็อกที่ดัชนี 281

ag:gitlab.com พบได้ที่ดัชนี 282

ab.com พบได้ที่ดัชนี 283

กินที่ดัชนี284

กินที่ดัชนี285

กินที่ดัชนี 286

กินที่ดัชนี 287

กินที่ดัชนี288

พบที่ดัชนี 289

พบที่ดัชนี290

a:thu พบที่ดัชนี 291

bnail w พบที่ดัชนี 292

Atar อยู่ที่ดัชนี 293

com พบได้ที่ดัชนี 294

Atar อยู่ที่ดัชนี 295

พบ c2f ที่ดัชนี 296

c58ed พบที่ดัชนี 297

พบได้ที่ดัชนี 298

กินที่ดัชนี299

ame อยู่ที่ดัชนี300

พบได้ที่ดัชนี301

ame อยู่ที่ดัชนี 302

ccc พบที่ดัชนี 303'

# Print the match result

str.scan(re) do |match|

    puts match.to_s

end


"""##
let stringRange = NSRange(location: 0, length: testString.utf16.count)
let matches = regex.matches(in: testString, range: stringRange)
var result: [[String]] = []
for match in matches {
    var groups: [String] = []
    for rangeIndex in 1 ..< match.numberOfRanges {
        groups.append((testString as NSString).substring(with: match.range(at: rangeIndex)))
    }
    if !groups.isEmpty {
        result.append(groups)
    }
}
print(result)
